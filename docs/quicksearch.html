<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"gitHubServer_entities_actions.js.html":{"id":"gitHubServer_entities_actions.js.html","title":"Source: gitHubServer/entities/actions.js","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Source: gitHubServer/entities/actions.js /** * Actions entity class for GitHub workflow operations * @file actions.js * @license Apache-2.0 * @version 3.0.0 * * @author Michael Hay &lt;michael.hay@mediumroast.io&gt; * @copyright 2024 Mediumroast, Inc. All rights reserved. */ import { BaseObjects } from '../baseObjects.js'; import { logger } from '../logger.js'; export class Actions extends BaseObjects { /** * @constructor * @param {string} token - GitHub API token * @param {string} org - GitHub organization name * @param {string} processName - Process name for locking */ constructor(token, org, processName) { super(token, org, processName, 'Actions'); // Add actions-specific cache keys this._cacheKeys.workflowRuns = 'workflow_runs'; this._cacheKeys.actionsBilling = 'actions_billing'; // Set specific cache timeouts this.cacheTimeouts.workflowRuns = 60000; // 1 minute for workflow runs (dynamic data) this.cacheTimeouts.actionsBilling = 3600000; // 1 hour for billing info } /** * Update GitHub Actions workflow files * @returns {Promise&lt;Array&gt;} Operation result */ async updateActions() { // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'updateActions') : { end: () =&gt; {} }; try { return await this._executeTransaction([ // Step 1: Get action manifest async () =&gt; { try { const manifestResp = await this.serverCtl.getActionsManifest(); if (!manifestResp[0]) { return manifestResp; } // Store for next step this._tempManifest = manifestResp[2]; return this._createSuccess('Retrieved actions manifest'); } catch (err) { logger.error('Failed to retrieve actions manifest', err); return this._createError( `Failed to retrieve actions manifest: ${err.message}`, err, 500 ); } }, // Step 2: Install or update each action async () =&gt; { const installStatus = []; for (const action of this._tempManifest) { try { // Check if action exists const actionExists = await this.serverCtl.actionExists(action.name); let result; if (actionExists[0] &amp;&amp; actionExists[2]) { // Update existing action result = await this.serverCtl.updateAction( action.name, action.content, actionExists[2] // SHA ); } else { // Create new action result = await this.serverCtl.createAction( action.name, action.content ); } // Add to status with operation type installStatus.push({ name: action.name, operation: actionExists[0] &amp;&amp; actionExists[2] ? 'updated' : 'created', success: result[0], message: result[1], timestamp: new Date().toISOString() }); } catch (err) { logger.error(`Failed to install action [${action.name}]`, err); installStatus.push({ name: action.name, operation: 'failed', success: false, message: err.message, timestamp: new Date().toISOString() }); } } // If all installations failed, return error if (installStatus.every(status =&gt; !status.success)) { return this._createError( 'All action installations failed', installStatus, 500 ); } return this._createSuccess( `Actions installation completed: ${installStatus.filter(s =&gt; s.success).length} succeeded, ${installStatus.filter(s =&gt; !s.success).length} failed`, installStatus ); } ], 'update-actions'); } finally { tracking.end(); } } /** * Get actions billing information * @returns {Promise&lt;Array&gt;} Billing information */ async getActionsBilling() { // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'getActionsBilling') : { end: () =&gt; {} }; try { // Use the standardized cache key structure return await this.cache.getOrFetch( this._cacheKeys.actionsBilling, async () =&gt; this.serverCtl.getActionsBillings(), this.cacheTimeouts.actionsBilling || 60000, [] // No dependencies ); } catch (error) { return this._createError( `Failed to retrieve Actions billing: ${error.message}`, error, 500 ); } finally { tracking.end(); } } /** * Get all workflow runs * @returns {Promise&lt;Array&gt;} List of workflow runs */ async getAll() { // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'getAll') : { end: () =&gt; {} }; try { return await this.cache.getOrFetch( this._cacheKeys.workflowRuns, async () =&gt; { try { // Try the original implementation first return await this.serverCtl.getWorkflowRuns(); } catch (error) { // If the error is specifically about missing the method, use a fallback if (error.message &amp;&amp; error.message.includes('getWorkflowRuns is not a function')) { logger.warn('getWorkflowRuns not implemented in github.js, using fallback implementation'); // Fallback implementation - returns an empty successful response return [ true, 'Workflow runs functionality not fully implemented', { workflow_runs: [], total_count: 0, message: 'This is a placeholder. The getWorkflowRuns method needs to be implemented in the github.js file.' } ]; } // If it's another error, rethrow it throw error; } }, this.cacheTimeouts.workflowRuns || 60000, [] // No dependencies ); } catch (error) { return this._createError( `Failed to retrieve workflow runs: ${error.message}`, error, 500 ); } finally { tracking.end(); } } /** * Get details for a specific workflow run * @param {string} runId - Workflow run ID * @returns {Promise&lt;Array&gt;} Workflow run details */ async getWorkflowRun(runId) { // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'getWorkflowRun') : { end: () =&gt; {} }; try { // Use standardized parameter validation const validationError = this._validateParams( { runId }, { runId: 'string' } ); if (validationError) return validationError; // Use cache for individual runs with dependency on all runs const runCacheKey = `${this._cacheKeys.workflowRuns}_${runId}`; return await this.cache.getOrFetch( runCacheKey, async () =&gt; this.serverCtl.getWorkflowRun(runId), this.cacheTimeouts.workflowRuns || 60000, [this._cacheKeys.workflowRuns] // Depends on all workflow runs ); } catch (error) { return this._createError( `Failed to retrieve workflow run: ${error.message}`, error, 500 ); } finally { tracking.end(); } } /** * Cancel a workflow run * @param {string} runId - Workflow run ID to cancel * @returns {Promise&lt;Array&gt;} Result of operation */ async cancelWorkflowRun(runId) { // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'cancelWorkflowRun') : { end: () =&gt; {} }; try { // Use standardized parameter validation const validationError = this._validateParams( { runId }, { runId: 'string' } ); if (validationError) return validationError; const result = await this.serverCtl.cancelWorkflowRun(runId); // Invalidate cache on successful cancellation if (result[0]) { // Invalidate both the specific run and the list of all runs this.cache.invalidate(this._cacheKeys.workflowRuns); this.cache.invalidate(`${this._cacheKeys.workflowRuns}_${runId}`); } return result; } catch (error) { return this._createError( `Failed to cancel workflow run: ${error.message}`, error, 500 ); } finally { tracking.end(); } } /** * Trigger a specific workflow * @param {string} workflowId - Workflow file name (e.g., \"main.yml\") * @param {Object} inputs - Workflow inputs * @returns {Promise&lt;Array&gt;} Result of operation */ async triggerWorkflow(workflowId, inputs = {}) { // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'triggerWorkflow') : { end: () =&gt; {} }; try { // Use standardized parameter validation const validationError = this._validateParams( { workflowId, inputs }, { workflowId: 'string', inputs: 'object' } ); if (validationError) return validationError; const result = await this.serverCtl.dispatchWorkflow(workflowId, inputs); // Invalidate cache on successful trigger if (result[0]) { this.cache.invalidate(this._cacheKeys.workflowRuns); } return result; } catch (error) { return this._createError( `Failed to trigger workflow: ${error.message}`, error, 500 ); } finally { tracking.end(); } } /** * Get usage metrics for GitHub Actions * @returns {Promise&lt;Array&gt;} Actions usage metrics */ async getUsageMetrics() { // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'getUsageMetrics') : { end: () =&gt; {} }; try { // Use the standardized cache key structure for metrics return await this.cache.getOrFetch( this._cacheKeys.metrics, async () =&gt; { // Get billing information const billingResp = await this.getActionsBilling(); if (!billingResp[0]) { return billingResp; } // Get recent workflow runs const runsResp = await this.getAll(); if (!runsResp[0]) { return runsResp; } // Calculate metrics from the data const billing = billingResp[2]; const runs = runsResp[2]; // Count runs by status const statusCounts = {}; const workflowCounts = {}; runs.forEach(run =&gt; { // Count by status statusCounts[run.status] = (statusCounts[run.status] || 0) + 1; // Count by workflow const workflowName = run.workflow_id || 'unknown'; workflowCounts[workflowName] = (workflowCounts[workflowName] || 0) + 1; }); // Build usage metrics const metrics = { billing: { included_minutes: billing.included_minutes, total_minutes_used: billing.total_minutes_used, minutes_used_breakdown: billing.minutes_used_breakdown, remaining_minutes: Math.max(0, billing.included_minutes - billing.total_minutes_used) }, runs: { total: runs.length, by_status: statusCounts, by_workflow: workflowCounts }, period: { start: billing.billing_period?.start_date, end: billing.billing_period?.end_date } }; return this._createSuccess( 'Actions usage metrics compiled successfully', metrics ); }, this.cacheTimeouts.metrics || 300000, [ this._cacheKeys.actionsBilling, // Metrics depend on billing data this._cacheKeys.workflowRuns // Metrics depend on workflow runs data ] ); } catch (error) { return this._createError( `Failed to get Actions usage metrics: ${error.message}`, error, 500 ); } finally { tracking.end(); } } } × Search results Close "},"github_billing.js.html":{"id":"github_billing.js.html","title":"Source: github/billing.js","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Source: github/billing.js /** * @fileoverview Billing operations for GitHub * @license Apache-2.0 * @version 3.0.0 */ import ResponseFactory from './response.js'; /** * Manages GitHub billing operations */ class BillingManager { /** * @constructor * @param {Object} octokit - Octokit instance * @param {String} orgName - GitHub organization name */ constructor(octokit, orgName) { this.octokit = octokit; this.orgName = orgName; } /** * Gets GitHub Actions billing information for the organization * @returns {Promise&lt;Array&gt;} ResponseFactory result */ async getActionsBillings() { try { const response = await this.octokit.rest.billing.getGithubActionsBillingOrg({ org: this.orgName, }); return ResponseFactory.success( `Successfully retrieved Actions billing information for organization ${this.orgName}`, response.data ); } catch (err) { return ResponseFactory.error( `Failed to retrieve Actions billing information: ${err.message}`, err, err.status || 500 ); } } /** * Gets GitHub Packages storage billing information for the organization * @returns {Promise&lt;Array&gt;} ResponseFactory result */ async getStorageBillings() { try { const response = await this.octokit.rest.billing.getSharedStorageBillingOrg({ org: this.orgName, }); return ResponseFactory.success( `Successfully retrieved storage billing information for organization ${this.orgName}`, response.data ); } catch (err) { return ResponseFactory.error( `Failed to retrieve storage billing information: ${err.message}`, err, err.status || 500 ); } } /** * Gets GitHub Packages billing information for the organization * @returns {Promise&lt;Array&gt;} ResponseFactory result */ async getPackagesBillings() { try { const response = await this.octokit.rest.billing.getGithubPackagesBillingOrg({ org: this.orgName, }); return ResponseFactory.success( `Successfully retrieved Packages billing information for organization ${this.orgName}`, response.data ); } catch (err) { return ResponseFactory.error( `Failed to retrieve Packages billing information: ${err.message}`, err, err.status || 500 ); } } /** * Gets all billing information for the organization * @returns {Promise&lt;Array&gt;} ResponseFactory result with combined billing data */ async getAllBillings() { try { const [actionsResult, storageResult, packagesResult] = await Promise.all([ this.getActionsBillings(), this.getStorageBillings(), this.getPackagesBillings() ]); if (!actionsResult[0] || !storageResult[0] || !packagesResult[0]) { const failedRequests = []; if (!actionsResult[0]) failedRequests.push('Actions'); if (!storageResult[0]) failedRequests.push('Storage'); if (!packagesResult[0]) failedRequests.push('Packages'); return ResponseFactory.error( `Failed to retrieve some billing information: ${failedRequests.join(', ')}`, { actionsResult, storageResult, packagesResult }, 500 ); } const combinedData = { actions: actionsResult[2], storage: storageResult[2], packages: packagesResult[2] }; return ResponseFactory.success( `Successfully retrieved all billing information for organization ${this.orgName}`, combinedData ); } catch (err) { return ResponseFactory.error( `Failed to retrieve billing information: ${err.message}`, err ); } } } export default BillingManager; × Search results Close "},"github_branch.js.html":{"id":"github_branch.js.html","title":"Source: github/branch.js","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Source: github/branch.js /** * @fileoverview Branch management operations for GitHub * @license Apache-2.0 * @version 3.0.0 */ import ResponseFactory from './response.js'; /** * Manages branch operations in GitHub */ class BranchManager { /** * @constructor * @param {Object} octokit - Octokit instance * @param {String} orgName - GitHub organization name * @param {String} repoName - GitHub repository name * @param {String} mainBranchName - Main branch name */ constructor(octokit, orgName, repoName, mainBranchName = 'main') { this.octokit = octokit; this.orgName = orgName; this.repoName = repoName; this.mainBranchName = mainBranchName; } /** * Creates a new branch from the main branch * @returns {Promise&lt;Array&gt;} ResponseFactory result */ async createBranchFromMain() { const branchName = Date.now().toString(); try { // Get the SHA of the latest commit on the main branch const mainBranchRef = await this.octokit.rest.git.getRef({ owner: this.orgName, repo: this.repoName, ref: `heads/${this.mainBranchName}`, }); // Create a new branch const newBranchResp = await this.octokit.rest.git.createRef({ owner: this.orgName, repo: this.repoName, ref: `refs/heads/${branchName}`, sha: mainBranchRef.data.object.sha, }); return ResponseFactory.success( `Created branch ${branchName}`, newBranchResp.data ); } catch (error) { return ResponseFactory.error( `Failed to create branch ${branchName}: ${error.message}`, error ); } } /** * Merges a branch into the main branch * @param {String} branchName - Branch to merge * @param {String} sha - Commit SHA * @param {String} commitDescription - Commit description * @returns {Promise&lt;Array&gt;} ResponseFactory result */ async mergeBranchToMain(branchName, sha, commitDescription = 'Performed CRUD operation on objects.') { try { // Create a pull request const createPullRequestResponse = await this.octokit.rest.pulls.create({ owner: this.orgName, repo: this.repoName, title: commitDescription, head: branchName, base: this.mainBranchName, body: commitDescription, }); // Merge the pull request const mergeResponse = await this.octokit.rest.pulls.merge({ owner: this.orgName, repo: this.repoName, pull_number: createPullRequestResponse.data.number, commit_title: commitDescription, }); return ResponseFactory.success( 'Pull request created and merged successfully', mergeResponse.data ); } catch (error) { return ResponseFactory.error( `Failed to create or merge pull request: ${error.message}`, error ); } } } export default BranchManager; × Search results Close "},"gitHubServer_cache.js.html":{"id":"gitHubServer_cache.js.html","title":"Source: gitHubServer/cache.js","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Source: gitHubServer/cache.js /** * Smart cache manager for GitHubServer */ export class CacheManager { constructor() { this._cache = new Map(); this._dependencyMap = new Map(); } /** * Gets a value from cache or fetches it * @param {string} key - Cache key * @param {Function} fetchFn - Function to fetch data if not cached * @param {number} ttl - Time to live in milliseconds * @param {Array&lt;string&gt;} dependencies - Keys this cache depends on */ async getOrFetch(key, fetchFn, ttl, dependencies = []) { const cached = this._cache.get(key); const now = Date.now(); if (cached &amp;&amp; (now - cached.timestamp &lt; ttl)) { return cached.data; } const data = await fetchFn(); if (data[0]) { // Only cache successful responses this._cache.set(key, { timestamp: now, data }); // Register dependencies dependencies.forEach(depKey =&gt; { if (!this._dependencyMap.has(depKey)) { this._dependencyMap.set(depKey, new Set()); } this._dependencyMap.get(depKey).add(key); }); } return data; } /** * Invalidate cache entry and its dependents * @param {string} key - Cache key to invalidate */ invalidate(key) { // Invalidate the key itself this._cache.delete(key); // Invalidate dependents const dependents = this._dependencyMap.get(key); if (dependents) { dependents.forEach(dependentKey =&gt; { this.invalidate(dependentKey); }); } } /** * Clear entire cache */ clear() { this._cache.clear(); this._dependencyMap.clear(); } } × Search results Close "},"gitHubServer_entities_companies.js.html":{"id":"gitHubServer_entities_companies.js.html","title":"Source: gitHubServer/entities/companies.js","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Source: gitHubServer/entities/companies.js import { BaseObjects } from '../baseObjects.js'; import { Interactions } from './interactions.js'; import { logger } from '../logger.js'; export class Companies extends BaseObjects { constructor(token, org, processName) { super(token, org, processName, 'Companies'); // Add profile-specific cache settings this._cacheKeys.profile = `${this.objType}_profile`; this.cacheTimeouts.profile = 600000; // 10 minutes for profiles } /** * Generates company profile with analytics * @param {string} name - Company name * @returns {Promise&lt;Array&gt;} Company profile */ async generateCompanyProfile(name) { // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'generateCompanyProfile') : { end: () =&gt; {} }; // Validate parameter const validationError = this._validateParams( { name }, { name: 'string' } ); if (validationError) return validationError; try { // Use cache with dependency on both company and interactions data const profileCacheKey = `${this._cacheKeys.profile}_${name}`; return await this.cache.getOrFetch( profileCacheKey, async () =&gt; { // Find the company const companyResp = await this.findByName(name); if (!companyResp[0]) { return companyResp; } const company = companyResp[2][0]; // Get linked interactions let linkedInteractionDetails = []; if (company.linked_interactions &amp;&amp; Object.keys(company.linked_interactions).length &gt; 0) { // Instantiate Interactions class to get details const interactionsClass = new Interactions( this.serverCtl.token, this.serverCtl.orgName, 'profile-generator' ); // Get details for each interaction for (const interactionName of Object.keys(company.linked_interactions)) { const interactionResp = await interactionsClass.findByName(interactionName); if (interactionResp[0]) { linkedInteractionDetails.push(interactionResp[2][0]); } } } // Analyze the interactions const analytics = { interactionCount: linkedInteractionDetails.length, contentTypes: {}, totalFileSize: 0, avgReadingTime: 0, totalWordCount: 0, avgPageCount: 0, lastModified: null, oldestInteraction: null }; // Process each interaction linkedInteractionDetails.forEach(interaction =&gt; { // Track content types analytics.contentTypes[interaction.content_type] = (analytics.contentTypes[interaction.content_type] || 0) + 1; // Track file sizes if (interaction.file_size) { analytics.totalFileSize += interaction.file_size; } // Track reading time if (interaction.reading_time) { analytics.avgReadingTime += interaction.reading_time; } // Track word count if (interaction.word_count) { analytics.totalWordCount += interaction.word_count; } // Track page count if (interaction.page_count) { analytics.avgPageCount += interaction.page_count; } // Track modification dates const modDate = new Date(interaction.modification_date); if (!analytics.lastModified || modDate &gt; new Date(analytics.lastModified)) { analytics.lastModified = interaction.modification_date; } if (!analytics.oldestInteraction || modDate &lt; new Date(analytics.oldestInteraction)) { analytics.oldestInteraction = interaction.modification_date; } }); // Calculate averages if (linkedInteractionDetails.length &gt; 0) { analytics.avgReadingTime /= linkedInteractionDetails.length; analytics.avgPageCount /= linkedInteractionDetails.length; } // Create company profile const profile = { ...company, analytics, interactionSummary: linkedInteractionDetails.map(i =&gt; ({ name: i.name, content_type: i.content_type, file_size: i.file_size, modification_date: i.modification_date, description: i.description })) }; return this._createSuccess( `Generated profile for company [${name}]`, profile ); }, this.cacheTimeouts.profile, [ this._cacheKeys.container, // Depends on company data 'container_Interactions' // Depends on interaction data ] ); } catch (error) { return this._createError( `Error generating company profile: ${error.message}`, error, 500 ); } finally { tracking.end(); } } /** * Link interactions to a company * @param {string} companyName - Name of the company * @param {Array&lt;Object&gt;} interactions - Interactions to link * @returns {Promise&lt;Array&gt;} Result of the operation */ async linkInteractions(companyName, interactions) { // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'linkInteractions') : { end: () =&gt; {} }; try { // Validate parameters const validationError = this._validateParams( { companyName, interactions }, { companyName: 'string', interactions: 'array' } ); if (validationError) return validationError; // Create linked objects hash const linkedInteractions = this.linkObj(interactions); // Update the company with linked interactions return await this.updateObj({ name: companyName, key: 'linked_interactions', value: linkedInteractions }); } catch (error) { return this._createError( `Error linking interactions to company: ${error.message}`, error, 500 ); } finally { tracking.end(); } } } × Search results Close "},"github_container.js.html":{"id":"github_container.js.html","title":"Source: github/container.js","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Source: github/container.js /** * @fileoverview Container operations for GitHub * @license Apache-2.0 * @version 3.0.0 */ import ResponseFactory from './response.js'; import { encodeContent } from './utils.js'; /** * Manages container operations (locking, object manipulation) */ class ContainerOperations { /** * @constructor * @param {Object} octokit - Octokit instance * @param {String} orgName - GitHub organization name * @param {String} repoName - GitHub repository name * @param {String} mainBranchName - Main branch name * @param {String} lockFileName - Lock file name */ constructor(octokit, orgName, repoName, mainBranchName, lockFileName) { this.octokit = octokit; this.orgName = orgName; this.repoName = repoName; this.mainBranchName = mainBranchName; this.lockFileName = lockFileName; } /** * Checks if a container is locked * @param {String} containerName - Container name * @returns {Promise&lt;Array&gt;} ResponseFactory result */ async checkForLock(containerName) { try { // Get the latest commit const latestCommit = await this.octokit.rest.repos.getCommit({ owner: this.orgName, repo: this.repoName, ref: this.mainBranchName, }); // Check if the lock file exists const mainContents = await this.octokit.rest.repos.getContent({ owner: this.orgName, repo: this.repoName, ref: latestCommit.data.sha, path: containerName }); const lockExists = mainContents.data.some( item =&gt; item.path === `${containerName}/${this.lockFileName}` ); if (lockExists) { return ResponseFactory.success( `Container ${containerName} is locked with lock file ${this.lockFileName}`, lockExists, 200 ); } else { return ResponseFactory.success( `Container ${containerName} is not locked with lock file ${this.lockFileName}`, lockExists, 404 ); } } catch (err) { return ResponseFactory.error( `Failed to check if container ${containerName} is locked: ${err.message}`, err ); } } /** * Locks a container * @param {String} containerName - Container name * @returns {Promise&lt;Array&gt;} ResponseFactory result */ async lockContainer(containerName) { // Define the full path to the lockfile const lockFile = `${containerName}/${this.lockFileName}`; try { // Get the latest commit const { data: latestCommit } = await this.octokit.rest.repos.getCommit({ owner: this.orgName, repo: this.repoName, ref: this.mainBranchName, }); const lockResponse = await this.octokit.rest.repos.createOrUpdateFileContents({ owner: this.orgName, repo: this.repoName, path: lockFile, content: encodeContent(''), branch: this.mainBranchName, message: `Locking container [${containerName}]`, sha: latestCommit.sha }); return ResponseFactory.success( `Locked the container ${containerName}`, lockResponse.data ); } catch (err) { return ResponseFactory.error( `Unable to lock the container ${containerName}: ${err.message}`, err ); } } /** * Unlocks a container * @param {String} containerName - Container name * @param {String} commitSha - SHA of the lock file * @param {String} branchName - Branch name * @returns {Promise&lt;Array&gt;} ResponseFactory result */ async unlockContainer(containerName, commitSha, branchName) { // Define the full path to the lockfile const lockFile = `${containerName}/${this.lockFileName}`; try { const lockExists = await this.checkForLock(containerName); if (lockExists[0] &amp;&amp; lockExists[2]) { const unlockResponse = await this.octokit.rest.repos.deleteFile({ owner: this.orgName, repo: this.repoName, path: lockFile, branch: branchName, message: `Unlocking container [${containerName}]`, sha: commitSha }); return ResponseFactory.success( `Unlocked the container ${containerName}`, unlockResponse.data ); } else { return ResponseFactory.error( `Unable to unlock the container ${containerName}: Lock file not found`, null ); } } catch (err) { return ResponseFactory.error( `Error unlocking container ${containerName}: ${err.message}`, err ); } } /** * Catches multiple containers (locks them and prepares for operations) * @param {Object} repoMetadata - Container metadata object * @param {Object} objectFiles - Mapping of container names to their object files * @param {Function} createBranchFn - Function to create a branch * @param {Function} readObjectsFn - Function to read container objects * @returns {Promise&lt;Array&gt;} ResponseFactory result */ async catchContainers(repoMetadata, objectFiles, createBranchFn, readObjectsFn) { // Check locks for (const container in repoMetadata.containers) { const lockExists = await this.checkForLock(container); if (lockExists[0] &amp;&amp; lockExists[2]) { return ResponseFactory.error( `The container [${container}] is locked unable and cannot perform creates, updates or deletes on objects.`, lockExists, 503 ); } } // Lock containers for (const container in repoMetadata.containers) { const locked = await this.lockContainer(container); if (!locked[0]) { return ResponseFactory.error( `Unable to lock [${container}] and cannot perform creates, updates or deletes on objects.`, locked, 503 ); } repoMetadata.containers[container].lockSha = locked[2].content.sha; } // Create branch const branchCreated = await createBranchFn(); if (!branchCreated[0]) { return ResponseFactory.error( 'Unable to create new branch', branchCreated, 503 ); } // Extract branch ref (remove 'refs/heads/' prefix) const branchRef = branchCreated[2].ref.replace('refs/heads/', ''); repoMetadata.branch = { name: branchRef, sha: branchCreated[2].object.sha }; // Read objects for (const container in repoMetadata.containers) { const readResponse = await readObjectsFn(container); if (!readResponse[0]) { return ResponseFactory.error( `Unable to read the source objects [${container}/${objectFiles[container]}].`, readResponse, 503 ); } repoMetadata.containers[container].objectSha = readResponse[2].sha; repoMetadata.containers[container].objects = readResponse[2].mrJson; } return ResponseFactory.success( `${Object.keys(repoMetadata.containers).length} containers are ready for use.`, repoMetadata, 200 ); } /** * Releases containers (unlocks them and merges changes) * @param {Object} repoMetadata - Container metadata object * @param {Function} mergeBranchFn - Function to merge branch to main * @returns {Promise&lt;Array&gt;} ResponseFactory result */ async releaseContainers(repoMetadata, mergeBranchFn) { // Merge branch to main const mergeResponse = await mergeBranchFn( repoMetadata.branch.name, repoMetadata.branch.sha ); if (!mergeResponse[0]) { return ResponseFactory.error( 'Unable to merge the branch to main.', mergeResponse, 503 ); } // Unlock containers for (const container in repoMetadata.containers) { // Unlock branch const branchUnlocked = await this.unlockContainer( container, repoMetadata.containers[container].lockSha, repoMetadata.branch.name ); if (!branchUnlocked[0]) { return ResponseFactory.error( `Unable to unlock the container, objects may have been written please check [${container}] for objects and the lock file.`, branchUnlocked, 503 ); } // Unlock main const mainUnlocked = await this.unlockContainer( container, repoMetadata.containers[container].lockSha, this.mainBranchName ); if (!mainUnlocked[0]) { return ResponseFactory.error( `Unable to unlock the container, objects may have been written please check [${container}] for objects and the lock file.`, mainUnlocked, 503 ); } } // Return success return ResponseFactory.success( `Released [${Object.keys(repoMetadata.containers).length}] containers.`, null, 200 ); } } export default ContainerOperations; × Search results Close "},"github.js.html":{"id":"github.js.html","title":"Source: github.js","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Source: github.js /** * @fileoverview A class that safely wraps RESTful calls to the GitHub API * @license Apache-2.0 * @version 3.0.0 * * @author Michael Hay &lt;michael.hay@mediumroast.io&gt; * @file github.js * @copyright 2025 Mediumroast, Inc. All rights reserved. * * @class GitHubFunctions * @classdesc Core functions needed to interact with the GitHub API for mediumroast.io. * * @requires octokit * * @exports GitHubFunctions * * @example * const gitHubCtl = new GitHubFunctions(accessToken, myOrgName, 'mr-cli-setup') * const createRepoResp = await gitHubCtl.createRepository() */ import { Octokit } from 'octokit'; // Import refactored modules import ResponseFactory from './github/response.js'; import ContainerOperations from './github/container.js'; import RepositoryManager from './github/repository.js'; import UserManager from './github/user.js'; import BillingManager from './github/billing.js'; import BranchManager from './github/branch.js'; import { encodeContent, decodeJsonContent, customEncodeURIComponent } from './github/utils.js'; import { isEmpty, isArray, deepClone, mergeObjects, formatDate } from '../utils/helpers.js'; class GitHubFunctions { /** * @constructor * @classdesc Core functions needed to interact with the GitHub API for mediumroast.io. * @param {String} token - the GitHub token for the mediumroast.io application * @param {String} org - the GitHub organization for the mediumroast.io application * @param {String} processName - the name of the process that is using the GitHub API * @memberof GitHubFunctions */ constructor(token, org, processName) { this.token = token; this.orgName = org; this.repoName = `${org}_discovery`; this.repoDesc = 'A repository for all of the mediumroast.io application assets.'; this.octCtl = new Octokit({auth: token}); this.lockFileName = `${processName}.lock`; this.mainBranchName = 'main'; this.objectFiles = { Studies: 'Studies.json', Companies: 'Companies.json', Interactions: 'Interactions.json', Users: null, Billings: null }; // Initialize our specialized managers this.repositoryManager = new RepositoryManager( this.octCtl, this.orgName, this.repoName, this.repoDesc, this.mainBranchName ); this.containerOps = new ContainerOperations( this.octCtl, this.orgName, this.repoName, this.mainBranchName, this.lockFileName ); this.userManager = new UserManager( this.octCtl, this.orgName, this.repoName ); this.billingManager = new BillingManager( this.octCtl, this.orgName ); this.branchManager = new BranchManager( this.octCtl, this.orgName, this.repoName, this.mainBranchName ); // Add field map for cross-references as a class property this.fieldMap = { Interactions: { Companies: 'linked_interactions' }, Companies: { Interactions: 'linked_companies' }, Studies: { Interactions: 'linked_studies', Companies: 'linked_studies' } }; // Add a cache for frequently used data this._cache = new Map(); this._defaultTtl = 60000; // 1 minute default TTL // Add transaction tracking for complex operations this._transactionDepth = 0; } /** * Gets or sets a value in the cache * @private * @param {String} key - Cache key * @param {Function} fetchFn - Function to fetch data if not in cache * @param {Number} ttlMs - Time to live in milliseconds * @returns {Promise&lt;Array&gt;} Cached or freshly fetched data */ async _getCachedOrFetch(key, fetchFn, ttlMs = this._defaultTtl) { const now = Date.now(); const cached = this._cache.get(key); // Return cached data if valid if (cached &amp;&amp; (now - cached.timestamp &lt; ttlMs)) { return cached.data; } // Otherwise fetch fresh data const result = await fetchFn(); // Only cache successful responses if (result[0]) { this._cache.set(key, { timestamp: now, data: result }); } return result; } /** * Invalidate a specific cache entry or the entire cache * @param {String} [key] - Optional key to invalidate specific entry */ invalidateCache(key = null) { if (key === null) { this._cache.clear(); } else { this._cache.delete(key); } } /** * Validates parameters against expected types * @private * @param {Object} params - Parameters to validate * @param {Object} expectedTypes - Expected types for each parameter * @returns {Array|null} Error response or null if valid */ _validateParams(params, expectedTypes) { for (const [name, value] of Object.entries(params)) { const expectedType = expectedTypes[name]; if (!expectedType) continue; if (expectedType === 'array') { if (!isArray(value)) { return ResponseFactory.error( `Invalid parameter: [${name}] must be an array`, null, 400 ); } } else if (expectedType === 'object') { if (typeof value !== 'object' || value === null) { return ResponseFactory.error( `Invalid parameter: [${name}] must be an object`, null, 400 ); } } else if (expectedType === 'string') { if (typeof value !== 'string' || isEmpty(value)) { return ResponseFactory.error( `Invalid parameter: [${name}] must be a non-empty string`, null, 400 ); } } else if (expectedType === 'boolean') { if (typeof value !== 'boolean') { return ResponseFactory.error( `Invalid parameter: [${name}] must be a boolean`, null, 400 ); } } else if (expectedType === 'number') { if (typeof value !== 'number') { return ResponseFactory.error( `Invalid parameter: [${name}] must be a number`, null, 400 ); } } } return null; // No validation errors } /** * Executes a series of operations as a transaction * @private * @param {Array&lt;Function&gt;} operations - Array of async functions to execute * @param {String} transactionName - Name of the transaction for logging * @returns {Promise&lt;Array&gt;} Result of the transaction */ async _executeTransaction(operations, transactionName) { this._transactionDepth++; const transactionId = `${transactionName}-${Date.now()}-${this._transactionDepth}`; try { const results = []; for (let i = 0; i &lt; operations.length; i++) { const operation = operations[i]; const operationName = operation.name || `Step${i+1}`; try { const result = await operation(); results.push(result); if (!result[0]) { // Operation failed, abort transaction return ResponseFactory.error( `Transaction [${transactionName}] failed at step [${operationName}]: ${result[1]}`, { transactionId, failedStep: operationName, stepResult: result, completedSteps: i }, result[3] || 500 ); } } catch (err) { return ResponseFactory.error( `Transaction [${transactionName}] failed at step [${operationName}]: ${err.message}`, { transactionId, failedStep: operationName, error: err, completedSteps: i }, 500 ); } } // All operations succeeded return ResponseFactory.success( `Transaction [${transactionName}] completed successfully`, results[results.length - 1][2], 200 ); } finally { this._transactionDepth--; } } /** * @async * @function getSha * @description Gets the SHA of a file in a container on a branch * @param {String} containerName - the name of the container to get the SHA from * @param {String} fileName - the short name of the file to get the SHA from * @param {String} branchName - the name of the branch to get the SHA from * @returns {Array} An array with position 0 being boolean to signify success/failure, position 1 being the response or error message, and position 2 being the SHA. * @memberof GitHubFunctions */ async getSha(containerName, fileName, branchName) { if (isEmpty(containerName) || isEmpty(fileName) || isEmpty(branchName)) { return ResponseFactory.error( `Missing required parameters: [containerName=${containerName}], [fileName=${fileName}], [branchName=${branchName}]`, null, 400 ); } const safePath = `${containerName}/${customEncodeURIComponent(fileName)}`; return this.repositoryManager.getSha(safePath, branchName); } /** * @async * @function getUser * @description Gets the authenticated user from the GitHub API * @returns {Array} An array with position 0 being boolean to signify success/failure and position 1 being the user info or error message. */ async getUser() { // User data typically stable during a session return this._getCachedOrFetch( 'current_user', () =&gt; this.userManager.getCurrentUser(), 300000 // 5 minutes ); } /** * @async * @function getAllUsers * @description Gets all of the users from the GitHub API * @returns {Array} An array with position 0 being boolean to signify success/failure and position 1 being the user info or error message. */ async getAllUsers() { // User list changes infrequently - 2 minute cache return this._getCachedOrFetch( 'all_users', () =&gt; this.userManager.getAllUsers(), 120000 // 2 minutes ); } /** * @async * @function getActionsBillings * @description Gets the complete billing status for actions from the GitHub API * @returns {Array} An array with position 0 being boolean to signify success/failure and position 1 being the user info or error message. */ async getActionsBillings() { return this.billingManager.getActionsBillings(); } /** * @async * @function getStorageBillings * @description Gets the complete billing status for actions from the GitHub API * @returns {Array} An array with position 0 being boolean to signify success/failure and position 1 being the user info or error message. */ async getStorageBillings() { return this.billingManager.getStorageBillings(); } /** * @function createRepository * @description Creates a repository, at the organization level, for keeping track of all mediumroast.io assets * @returns {Array} An array with position 0 being boolean to signify success/failure and position 1 being the created repo or error message. */ async createRepository() { return this.repositoryManager.createRepository(); } /** * @function getGitHubOrg * @description If the GitHub organization exists retrieves the detail about it and returns to the caller * @returns {Array} An array with position 0 being boolean to signify success/failure and position 1 being the org or error message. */ async getGitHubOrg() { // Organization data changes rarely - 5 minute cache return this._getCachedOrFetch( 'org_data', () =&gt; this.repositoryManager.getOrganization(), 300000 // 5 minutes ); } /** * @async * @function getWorkflowRuns * @description Gets all of the workflow runs for the repository * @returns {Array} An array with position 0 being boolean to signify success/failure and position 1 being the response or error message. */ async getWorkflowRuns() { // Workflow runs change more frequently - shorter cache return this._getCachedOrFetch( 'workflow_runs', () =&gt; this.repositoryManager.getWorkflowRuns(), 30000 // 30 seconds ); } /** * @async * @function getRepoSize * @description Gets the size of the repository in MB * @returns {Array} An array with position 0 being boolean to signify success/failure and position 1 being the response or error message. */ async getRepoSize() { // Repo size changes slowly - 1 minute cache return this._getCachedOrFetch( 'repo_size', () =&gt; this.repositoryManager.getRepoSize(), 60000 // 1 minute ); } /** * @function createContainers * @description Creates the top level Study, Company and Interaction containers for all mediumroast.io assets * @returns {Array} An array with position 0 being boolean to signify success/failure and position 1 being the responses or error messages. */ async createContainers(containers = ['Studies', 'Companies', 'Interactions']) { if (!isArray(containers)) { return ResponseFactory.error( 'Invalid parameter: [containers] must be an array', null, 400 ); } return this.repositoryManager.createContainers(containers); } /** * @description Creates a new branch from the main branch. * @function createBranchFromMain * @async * @returns {Promise&lt;Array&gt;} A promise that resolves to an array containing a boolean indicating success, a message, and the response. */ async createBranchFromMain() { return this.branchManager.createBranchFromMain(); } /** * @description Merges a specified branch into the main branch by creating a pull request. * @function mergeBranchToMain * @async * @param {string} branchName - The name of the branch to merge into main. * @param {string} mySha - The SHA of the commit to use as the head of the pull request. * @param {string} [commitDescription='Performed CRUD operation on objects.'] - The description of the commit. * @returns {Promise&lt;Array&gt;} A promise that resolves to an array containing success status, message, and response. */ async mergeBranchToMain(branchName, mySha, commitDescription='Performed CRUD operation on objects.') { if (isEmpty(branchName)) { return ResponseFactory.error( 'Missing required parameter: [branchName]', null, 400 ); } return this.branchManager.mergeBranchToMain(branchName, mySha, commitDescription); } /** * @description Checks to see if a container is locked. * @function checkForLock * @async * @param {string} containerName - The name of the container to check for a lock. * @returns {Promise&lt;Array&gt;} A promise that resolves to an array containing status and message. */ async checkForLock(containerName) { if (isEmpty(containerName)) { return ResponseFactory.error( 'Missing required parameter: [containerName]', null, 400 ); } return this.containerOps.checkForLock(containerName); } /** * @description Locks a container by creating a lock file in the container. * @function lockContainer * @async * @param {string} containerName - The name of the container to lock. * @returns {Promise&lt;Array&gt;} A promise that resolves to an array containing status and message. */ async lockContainer(containerName) { if (isEmpty(containerName)) { return ResponseFactory.error( 'Missing required parameter: [containerName]', null, 400 ); } return this.containerOps.lockContainer(containerName); } /** * @description Unlocks a container by deleting the lock file in the container. * @function unlockContainer * @async * @param {string} containerName - The name of the container to unlock. * @param {string} commitSha - The SHA of the commit to use as the head of the pull request. * @param {string} branchName - The name of the branch to unlock the container on. * @returns {Promise&lt;Array&gt;} A promise that resolves to an array containing status and message. */ async unlockContainer(containerName, commitSha, branchName = this.mainBranchName) { if (isEmpty(containerName) || isEmpty(commitSha)) { return ResponseFactory.error( `Missing required parameters: [containerName=${containerName}], [commitSha=${commitSha}]`, null, 400 ); } return this.containerOps.unlockContainer(containerName, commitSha, branchName); } /** * Read a blob (file) from a container (directory) in a specific branch. * @param {string} fileName - The name of the blob to read with a complete path to the file. * @returns {Array} A list containing success status, message, and the blob's raw data. */ async readBlob(fileName) { if (isEmpty(fileName)) { return ResponseFactory.error( 'Missing required parameter: [fileName]', null, 400 ); } // Create an enhanced repository manager method that handles decoding return this.repositoryManager.readBlobWithDecoding( customEncodeURIComponent(fileName), this.token ); } /** * Delete a blob (file) from a container (directory) * @param {string} containerName - The container name * @param {string} fileName - The file name * @param {string} branchName - The branch name * @param {string} sha - The SHA of the file * @returns {Array} A list containing success status, message, and response */ async deleteBlob(containerName, fileName, branchName, sha) { if (isEmpty(containerName) || isEmpty(fileName) || isEmpty(branchName) || isEmpty(sha)) { return ResponseFactory.error( `Missing required parameters: [containerName=${containerName}], [fileName=${fileName}], [branchName=${branchName}], [sha=${sha}]`, null, 400 ); } const safePath = `${containerName}/${customEncodeURIComponent(fileName)}`; return this.repositoryManager.deleteBlob(safePath, branchName, sha); } /** * Write a blob (file) to a container (directory) * @param {string} containerName - The container name * @param {string} fileName - The file name * @param {string} blob - The blob to write * @param {string} branchName - The branch name * @param {string} sha - The SHA of the file if updating * @returns {Array} A list containing success status, message, and response */ async writeBlob(containerName, fileName, blob, branchName, sha) { if (isEmpty(containerName) || isEmpty(fileName) || isEmpty(branchName)) { return ResponseFactory.error( `Missing required parameters: [containerName=${containerName}], [fileName=${fileName}], [branchName=${branchName}]`, null, 400 ); } const encodedContent = typeof blob === 'string' ? encodeContent(blob) : blob; return this.repositoryManager.writeBlob( containerName, customEncodeURIComponent(fileName), encodedContent, branchName, sha ); } /** * @function writeObject * @description Writes an object to a specified container using the GitHub API. * @async * @param {string} containerName - The name of the container to write the object to. * @param {object} obj - The object to write to the container. * @param {string} ref - The reference to use when writing the object. * @param {string} mySha - The SHA of the current file if updating. * @returns {Promise&lt;Array&gt;} Status, message, and response */ async writeObject(containerName, obj, ref, mySha) { // Invalidate relevant caches on write this.invalidateCache('repo_size'); this.invalidateCache(`container_${containerName}`); if (isEmpty(containerName) || obj === null || isEmpty(ref)) { return ResponseFactory.error( `Missing required parameters: [containerName=${containerName}], [obj=${obj !== null ? 'present' : 'null'}], [ref=${ref}]`, null, 400 ); } const content = encodeContent(obj); return this.repositoryManager.writeBlob( containerName, this.objectFiles[containerName], content, ref, mySha ); } /** * @function readObjects * @description Reads objects from a specified container using the GitHub API. * @async * @param {string} containerName - The name of the container to read objects from. * @returns {Promise&lt;Array&gt;} Status, message, and contents */ async readObjects(containerName) { if (isEmpty(containerName) || isEmpty(this.objectFiles[containerName])) { return ResponseFactory.error( `Invalid container name or no object file defined for ${containerName}`, null, 400 ); } const path = `${containerName}/${this.objectFiles[containerName]}`; const result = await this.repositoryManager.getContent( path, this.mainBranchName ); if (!result[0]) { return result; } const jsonContent = decodeJsonContent(result[2].content); if (jsonContent === null) { return ResponseFactory.error(`Unable to parse [${path}] as JSON`, new Error('JSON parse error')); } result[2].mrJson = jsonContent; return result; } /** * @function updateObject * @description Updates an object in a specified container * @async * @param {string} containerName - The name of the container containing the object * @param {string} objName - The name of the object to update * @param {string} key - The key of the object to update * @param {string} value - The value to update the key with * @param {boolean} [dontWrite=false] - A flag to indicate if the object should be written back * @param {boolean} [system=false] - A flag to indicate if the update is a system call * @param {Array} [whiteList=[]] - A list of keys that are allowed to be updated * @returns {Promise&lt;Array&gt;} Status, message, and response */ async updateObject(containerName, objName, key, value, dontWrite=false, system=false, whiteList=[]) { // Validate parameters using the new validation method const validationError = this._validateParams( { containerName, objName, key, dontWrite, system, whiteList }, { containerName: 'string', objName: 'string', key: 'string', dontWrite: 'boolean', system: 'boolean', whiteList: 'array' } ); if (validationError) return validationError; // Authorization check if (!system &amp;&amp; !whiteList.includes(key)) { return ResponseFactory.error( `Unauthorized operation: Updating the key [${key}] is not supported`, null, 403 ); } // Use transaction pattern for the complex update operation return this._executeTransaction([ // Step 1: Read the objects async () =&gt; { const readResponse = await this.readObjects(containerName); if (!readResponse[0]) { return ResponseFactory.error( `Unable to read source objects from [${containerName}]`, readResponse[2], 500 ); } // Store the read response for next steps this._tempReadResponse = readResponse; return readResponse; }, // Step 2: Catch the container if needed async () =&gt; { if (dontWrite) { return ResponseFactory.success( 'Skipping container locking for read-only update', null ); } const repoMetadata = {containers: {}, branch: {}}; repoMetadata.containers[containerName] = {}; const caught = await this.catchContainer(repoMetadata); // Store the caught data for next steps this._tempCaught = caught; return caught; }, // Step 3: Update the object async () =&gt; { const objectsCopy = deepClone(this._tempReadResponse[2].mrJson); let objectFound = false; for (const obj in objectsCopy) { if (objectsCopy[obj].name === objName) { objectFound = true; const updates = { [key]: value, modification_date: formatDate(new Date()) }; objectsCopy[obj] = mergeObjects(objectsCopy[obj], updates); } } if (!objectFound) { return ResponseFactory.error( `Object with name [${objName}] not found in [${containerName}]`, null, 404 ); } // Store updated objects for next steps this._tempUpdatedObjects = objectsCopy; if (dontWrite) { return ResponseFactory.success( `Merged updates object(s) with [${containerName}] objects`, objectsCopy ); } return ResponseFactory.success('Object updated in memory', objectsCopy); }, // Step 4: Write the objects (if not dontWrite) async () =&gt; { if (dontWrite) { return ResponseFactory.success( 'Skipping writing for read-only update', this._tempUpdatedObjects ); } const writeResponse = await this.writeObject( containerName, this._tempUpdatedObjects, this._tempCaught[2].branch.name, this._tempCaught[2].containers[containerName].objectSha ); return writeResponse; }, // Step 5: Release the container (if not dontWrite) async () =&gt; { if (dontWrite) { return ResponseFactory.success( 'Skipping container release for read-only update', this._tempUpdatedObjects ); } return this.releaseContainer(this._tempCaught[2]); } ], `update-object-${containerName}-${objName}`); } /** * @function deleteObject * @description Deletes an object from a specified container * @async * @param {string} objName - The name of the object to delete * @param {object} source - The source object that contains the from and to containers * @param {object} repoMetadata - The repository metadata * @param {boolean} catchIt - Whether to catch the container * @returns {Promise&lt;Array&gt;} Status, message, and response */ async deleteObject(objName, source, repoMetadata=null, catchIt=true) { // Validate parameters const validationError = this._validateParams( { objName, source, catchIt }, { objName: 'string', source: 'object', catchIt: 'boolean' } ); if (validationError) return validationError; // Additional validation for source object if (isEmpty(source.from) || !isArray(source.to) || source.to.length === 0) { return ResponseFactory.error( 'Invalid source configuration: [from] must be a non-empty string and [to] must be a non-empty array', null, 400 ); } // Define transaction steps const deleteSteps = []; // Step 1: Catch container if needed if (catchIt) { deleteSteps.push(async () =&gt; { const metadata = {containers: {}, branch: {}}; metadata.containers[source.from] = {}; metadata.containers[source.to[0]] = {}; const caught = await this.catchContainer(metadata); // Store for later steps this._tempRepoMetadata = deepClone(caught[2]); return caught; }); } else { deleteSteps.push(async () =&gt; { this._tempRepoMetadata = repoMetadata; return ResponseFactory.success('Using provided repository metadata', repoMetadata); }); } // Step 2: Find and delete the object deleteSteps.push(async () =&gt; { let objectFound = false; for (const obj in this._tempRepoMetadata.containers[source.from].objects) { if (this._tempRepoMetadata.containers[source.from].objects[obj].name === objName) { objectFound = true; // For Interactions, delete the actual file if (source.from === 'Interactions') { const fileName = this._tempRepoMetadata.containers[source.from].objects[obj].url; try { const { data } = await this.octCtl.rest.repos.getContent({ owner: this.orgName, repo: this.repoName, path: customEncodeURIComponent(fileName) }); const fileBits = fileName.split('/'); const shortFilename = fileBits[fileBits.length - 1]; const deleteResponse = await this.deleteBlob( source.from, shortFilename, this._tempRepoMetadata.branch.name, data.sha ); if (!deleteResponse[0]) { return deleteResponse; // Transaction will abort } } catch (err) { return ResponseFactory.error( `Failed to get content for [${fileName}]: ${err.message}`, err, 503 ); } } // Remove the object from the array this._tempRepoMetadata.containers[source.from].objects.splice(obj, 1); break; } } if (!objectFound) { return ResponseFactory.error( `Object with name [${objName}] not found in [${source.from}]`, null, 404 ); } return ResponseFactory.success(`Found and removed object [${objName}]`, null); }); // Step 3: Update references in linked objects deleteSteps.push(async () =&gt; { for (const obj in this._tempRepoMetadata.containers[source.to[0]].objects) { if (this._tempRepoMetadata.containers[source.to[0]].objects[obj][this.fieldMap[source.from][source.to[0]]] &amp;&amp; objName in this._tempRepoMetadata.containers[source.to[0]].objects[obj][this.fieldMap[source.from][source.to[0]]]) { delete this._tempRepoMetadata.containers[source.to[0]].objects[obj][this.fieldMap[source.from][source.to[0]]][objName]; // Update modification date using the helper function this._tempRepoMetadata.containers[source.to[0]].objects[obj].modification_date = formatDate(new Date()); } } return ResponseFactory.success('Updated cross-references', null); }); // Add steps for writing changes deleteSteps.push( // Step 4: Write source container async () =&gt; { const fromSha = await this.getSha(source.from, this.objectFiles[source.from], this._tempRepoMetadata.branch.name); if (!fromSha[0]) { return fromSha; // Transaction will abort } return this.writeObject( source.from, this._tempRepoMetadata.containers[source.from].objects, this._tempRepoMetadata.branch.name, fromSha[2] ); }, // Step 5: Write target container async () =&gt; { const toSha = await this.getSha(source.to[0], this.objectFiles[source.to[0]], this._tempRepoMetadata.branch.name); if (!toSha[0]) { return toSha; // Transaction will abort } return this.writeObject( source.to[0], this._tempRepoMetadata.containers[source.to[0]].objects, this._tempRepoMetadata.branch.name, toSha[2] ); } ); // Step 6: Release container if needed if (catchIt) { deleteSteps.push(async () =&gt; { return this.releaseContainer(this._tempRepoMetadata); }); } else { deleteSteps.push(async () =&gt; { return ResponseFactory.success( `Deleted [${source.from}] object of the name [${objName}] without releasing container`, null ); }); } // Execute the delete transaction return this._executeTransaction(deleteSteps, `delete-object-${source.from}-${objName}`); } /** * @function catchContainer * @description Catches a container by locking it, creating a new branch, reading the objects * @param {Object} repoMetadata - The metadata object * @returns {Promise&lt;Array&gt;} Status, message, and metadata */ async catchContainer(repoMetadata) { if (!repoMetadata || !repoMetadata.containers || Object.keys(repoMetadata.containers).length === 0) { return ResponseFactory.error( 'Invalid parameter: [repoMetadata] must contain containers property with at least one container', null, 400 ); } return this.containerOps.catchContainers( repoMetadata, this.objectFiles, () =&gt; this.branchManager.createBranchFromMain(), (container) =&gt; this.readObjects(container) ); } /** * @function releaseContainer * @description Releases a container by unlocking it and merging the branch * @param {Object} repoMetadata - The metadata object * @returns {Promise&lt;Array&gt;} Status, message, and response */ async releaseContainer(repoMetadata) { if (!repoMetadata || !repoMetadata.containers || !repoMetadata.branch) { return ResponseFactory.error( 'Invalid parameter: [repoMetadata] must contain containers and branch information', null, 400 ); } return this.containerOps.releaseContainers( repoMetadata, (branchName, branchSha) =&gt; this.branchManager.mergeBranchToMain(branchName, branchSha) ); } } export default GitHubFunctions; × Search results Close "},"gitHubServer_entities_interactions.js.html":{"id":"gitHubServer_entities_interactions.js.html","title":"Source: gitHubServer/entities/interactions.js","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Source: gitHubServer/entities/interactions.js import { BaseObjects } from '../baseObjects.js'; import { logger } from '../logger.js'; export class Interactions extends BaseObjects { constructor(token, org, processName) { super(token, org, processName, 'Interactions'); // Add interaction-specific cache settings this._cacheKeys.byHash = `${this.objType}_byHash`; this._cacheKeys.byText = `${this.objType}_byText`; this._cacheKeys.analysis = `${this.objType}_analysis`; this._cacheKeys.topics = `${this.objType}_topics`; this._cacheKeys.similar = `${this.objType}_similar`; // Set cache timeouts this.cacheTimeouts.analysis = 600000; // 10 minutes for content analysis this.cacheTimeouts.topics = 600000; // 10 minutes for topics this.cacheTimeouts.similar = 600000; // 10 minutes for similarity results } /** * Override deleteObj to handle cross-entity references * @param {string} objName - Name of the interaction to delete * @returns {Promise&lt;Array&gt;} Operation result */ async deleteObj(objName) { // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'deleteObj') : { end: () =&gt; {} }; try { const source = { from: 'Interactions', to: ['Companies'] }; return await super.deleteObj(objName, source); } finally { tracking.end(); } } /** * Find interaction by file hash * @param {string} hash - File hash to search for * @returns {Promise&lt;Array&gt;} Found interaction or error */ async findByHash(hash) { // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'findByHash') : { end: () =&gt; {} }; try { // Validate parameters const validationError = this._validateParams( { hash }, { hash: 'string' } ); if (validationError) return validationError; // Use cache with dependencies to container data const hashCacheKey = `${this._cacheKeys.byHash}_${hash}`; return await this.cache.getOrFetch( hashCacheKey, () =&gt; this.findByX('file_hash', hash), this.cacheTimeouts[this.objType] || 180000, [this._cacheKeys.container] // Depends on all interactions ); } finally { tracking.end(); } } /** * Finds interactions containing specific text in content or metadata * @param {string} text - The text to search for * @returns {Promise&lt;Array&gt;} Search results */ async findByText(text) { // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'findByText') : { end: () =&gt; {} }; try { // Validate parameters const validationError = this._validateParams( { text }, { text: 'string' } ); if (validationError) return validationError; // Use cache with text search key const textCacheKey = `${this._cacheKeys.byText}_${text.toLowerCase()}`; return await this.cache.getOrFetch( textCacheKey, async () =&gt; { const allObjectsResp = await this.getAll(); if (!allObjectsResp[0]) { return allObjectsResp; } const allObjects = allObjectsResp[2].mrJson; const searchText = text.toLowerCase(); // Search through text fields const results = allObjects.filter(interaction =&gt; { if (interaction.name?.toLowerCase().includes(searchText)) return true; if (interaction.abstract?.toLowerCase().includes(searchText)) return true; if (interaction.description?.toLowerCase().includes(searchText)) return true; if (interaction.summary?.toLowerCase().includes(searchText)) return true; return false; }); if (results.length === 0) { return this._createError( `No interactions found containing text: \"${text}\"`, null, 404 ); } return this._createSuccess( `Found ${results.length} interactions containing text: \"${text}\"`, results ); }, this.cacheTimeouts[this.objType] || 180000, [this._cacheKeys.container] // Depends on all interactions ); } catch (error) { return this._createError( `Error searching interactions: ${error.message}`, error, 500 ); } finally { tracking.end(); } } /** * Gets detailed content analysis for an interaction * @param {string} name - Interaction name * @returns {Promise&lt;Array&gt;} Analysis results */ async getInteractionAnalysis(name) { // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'getInteractionAnalysis') : { end: () =&gt; {} }; try { // Validate parameter const validationError = this._validateParams( { name }, { name: 'string' } ); if (validationError) return validationError; // Use cache for analysis results const analysisCacheKey = `${this._cacheKeys.analysis}_${name}`; return await this.cache.getOrFetch( analysisCacheKey, async () =&gt; { // Find the interaction const interactionResp = await this.findByName(name); if (!interactionResp[0]) { return interactionResp; } const interaction = interactionResp[2][0]; // Check if this interaction has content to analyze if (!interaction.url) { return this._createError( `Interaction [${name}] does not have content to analyze`, null, 400 ); } // Use transaction pattern for better error handling return this._executeTransaction([ // Step 1: Read the content async () =&gt; { try { const contentResp = await this.serverCtl.readBlob(interaction.url); if (!contentResp[0]) { return contentResp; } // Store for next steps this._tempContent = contentResp[2].decodedContent; return this._createSuccess('Retrieved interaction content'); } catch (err) { return this._createError( `Failed to read interaction content: ${err.message}`, err, 500 ); } }, // Step 2: Analyze the content async () =&gt; { // Get word frequencies const words = this._tempContent .toLowerCase() .replace(/[^\\w\\s]/g, ' ') .split(/\\s+/) .filter(word =&gt; word.length &gt; 3); const wordFreq = {}; words.forEach(word =&gt; { wordFreq[word] = (wordFreq[word] || 0) + 1; }); // Sort by frequency const sortedWords = Object.entries(wordFreq) .sort(([,a], [,b]) =&gt; b - a) .slice(0, 50) .reduce((obj, [k, v]) =&gt; ({ ...obj, [k]: v }), {}); // Basic sentiment analysis const positiveWords = ['good', 'great', 'excellent', 'positive', 'advantage', 'benefit']; const negativeWords = ['bad', 'poor', 'negative', 'disadvantage', 'problem', 'issue']; let sentimentScore = 0; words.forEach(word =&gt; { if (positiveWords.includes(word)) sentimentScore++; if (negativeWords.includes(word)) sentimentScore--; }); // Create analysis object const analysis = { topWords: sortedWords, totalWords: words.length, uniqueWords: Object.keys(wordFreq).length, avgWordLength: words.reduce((sum, word) =&gt; sum + word.length, 0) / words.length, sentiment: { score: sentimentScore, normalized: words.length &gt; 0 ? sentimentScore / words.length : 0, interpretation: sentimentScore &gt; 0 ? 'Positive' : sentimentScore &lt; 0 ? 'Negative' : 'Neutral' }, metadata: { contentType: interaction.content_type, fileSize: interaction.file_size, readingTime: interaction.reading_time, wordCount: interaction.word_count, pageCount: interaction.page_count } }; return this._createSuccess( `Analysis completed for interaction [${name}]`, analysis ); } ], `analyze-interaction-${name}`); }, this.cacheTimeouts.analysis || 600000, [ this._cacheKeys.container, // Depends on interaction data `${this._cacheKeys.byName}_${name}` // Depends on this specific interaction ] ); } catch (error) { return this._createError( `Error analyzing interaction: ${error.message}`, error, 500 ); } finally { tracking.end(); } } /** * Extracts topics from an interaction's content * @param {string} name - Interaction name * @returns {Promise&lt;Array&gt;} Extracted topics */ async extractTopics(name) { // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'extractTopics') : { end: () =&gt; {} }; try { // Validate parameter const validationError = this._validateParams( { name }, { name: 'string' } ); if (validationError) return validationError; // Use cache for topics with dependency on analysis const topicsCacheKey = `${this._cacheKeys.topics}_${name}`; return await this.cache.getOrFetch( topicsCacheKey, async () =&gt; { // First get the content analysis which contains word frequencies const analysisResp = await this.getInteractionAnalysis(name); if (!analysisResp[0]) { return analysisResp; } const topWords = analysisResp[2].topWords; // Filter common stop words const stopWords = ['this', 'that', 'then', 'than', 'they', 'them', 'their', 'there', 'here', 'where']; const topics = Object.entries(topWords) .filter(([word]) =&gt; !stopWords.includes(word)) .slice(0, 10) .map(([word, count]) =&gt; ({ topic: word, count })); return this._createSuccess( `Extracted topics for interaction [${name}]`, topics ); }, this.cacheTimeouts.topics || 600000, [ `${this._cacheKeys.analysis}_${name}` // Depends on content analysis ] ); } catch (error) { return this._createError( `Error extracting topics: ${error.message}`, error, 500 ); } finally { tracking.end(); } } /** * Finds similar interactions based on content analysis * @param {string} name - Name of the base interaction * @returns {Promise&lt;Array&gt;} Similar interactions */ async findSimilar(name) { // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'findSimilar') : { end: () =&gt; {} }; try { // Validate parameter const validationError = this._validateParams( { name }, { name: 'string' } ); if (validationError) return validationError; // Use cache for similarity results const similarCacheKey = `${this._cacheKeys.similar}_${name}`; return await this.cache.getOrFetch( similarCacheKey, async () =&gt; { // Get the interaction const interactionResp = await this.findByName(name); if (!interactionResp[0]) { return interactionResp; } const interaction = interactionResp[2][0]; // Get all interactions const allObjectsResp = await this.getAll(); if (!allObjectsResp[0]) { return allObjectsResp; } // Filter out the current interaction const otherInteractions = allObjectsResp[2].mrJson.filter(i =&gt; i.name !== name); // Compare by metadata similarity const similarities = otherInteractions.map(other =&gt; { let score = 0; // Content type match if (other.content_type === interaction.content_type) score += 1; // Similar length const sizeDiff = Math.abs( (other.file_size || 0) - (interaction.file_size || 0) ) / Math.max(other.file_size || 1, interaction.file_size || 1); score += (1 - sizeDiff); // Similar reading time if (other.reading_time &amp;&amp; interaction.reading_time) { const timeDiff = Math.abs(other.reading_time - interaction.reading_time) / Math.max(other.reading_time, interaction.reading_time); score += (1 - timeDiff); } // Same company if (other.linked_companies &amp;&amp; interaction.linked_companies) { const otherCompanies = Object.keys(other.linked_companies); const thisCompanies = Object.keys(interaction.linked_companies); for (const company of thisCompanies) { if (otherCompanies.includes(company)) { score += 2; break; } } } return { name: other.name, score, metadata: { content_type: other.content_type, file_size: other.file_size, reading_time: other.reading_time } }; }); // Sort by score and take top 5 const topSimilar = similarities .sort((a, b) =&gt; b.score - a.score) .slice(0, 5); return this._createSuccess( `Found similar interactions for [${name}]`, topSimilar ); }, this.cacheTimeouts.similar || 600000, [ this._cacheKeys.container, // Depends on all interactions `${this._cacheKeys.byName}_${name}` // Depends on this specific interaction ] ); } catch (error) { return this._createError( `Error finding similar interactions: ${error.message}`, error, 500 ); } finally { tracking.end(); } } /** * Group interactions by common attributes * @param {string} attribute - Attribute to group by (e.g., 'content_type') * @returns {Promise&lt;Array&gt;} Grouped interactions */ async groupBy(attribute) { // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'groupBy') : { end: () =&gt; {} }; try { // Validate parameter const validationError = this._validateParams( { attribute }, { attribute: 'string' } ); if (validationError) return validationError; // Get all interactions const allResp = await this.getAll(); if (!allResp[0]) { return allResp; } const interactions = allResp[2].mrJson; // Group by the specified attribute const groups = {}; interactions.forEach(interaction =&gt; { const value = interaction[attribute] || 'unknown'; if (!groups[value]) { groups[value] = []; } groups[value].push({ name: interaction.name, content_type: interaction.content_type, file_size: interaction.file_size }); }); // Convert to array of groups const result = Object.entries(groups).map(([key, items]) =&gt; ({ group: key, count: items.length, items })); return this._createSuccess( `Interactions grouped by ${attribute}`, result ); } catch (error) { return this._createError( `Error grouping interactions: ${error.message}`, error, 500 ); } finally { tracking.end(); } } } × Search results Close "},"github_repository.js.html":{"id":"github_repository.js.html","title":"Source: github/repository.js","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Source: github/repository.js /** * @fileoverview Repository operations for GitHub * @license Apache-2.0 * @version 3.0.0 */ import ResponseFactory from './response.js'; import { encodeContent } from './utils.js'; /** * Manages low-level GitHub repository operations */ class RepositoryManager { /** * @constructor * @param {Object} octokit - Octokit instance * @param {String} orgName - GitHub organization name * @param {String} repoName - GitHub repository name */ constructor(octokit, orgName, repoName) { this.octokit = octokit; this.orgName = orgName; this.repoName = repoName; } /** * Gets content from the repository * @param {String} path - Path to the content * @param {String} ref - Branch or commit reference * @returns {Promise&lt;Array&gt;} ResponseFactory result */ async getContent(path, ref) { try { const response = await this.octokit.rest.repos.getContent({ owner: this.orgName, repo: this.repoName, path, ref }); return ResponseFactory.success(`Retrieved content at ${path}`, response.data); } catch (err) { return ResponseFactory.error(`Failed to get content at ${path}: ${err.message}`, err); } } /** * Creates or updates a file in the repository * @param {String} path - Path to the file * @param {String|Object} content - Content to write (will be encoded) * @param {String} message - Commit message * @param {String} branch - Branch name * @param {String} sha - SHA of the file (if updating) * @returns {Promise&lt;Array&gt;} ResponseFactory result */ async createOrUpdateFile(path, content, message, branch, sha = null) { try { const params = { owner: this.orgName, repo: this.repoName, path, message, content: encodeContent(content), branch }; if (sha) params.sha = sha; const response = await this.octokit.rest.repos.createOrUpdateFileContents(params); return ResponseFactory.success(`Updated ${path}`, response.data); } catch (err) { return ResponseFactory.error(`Failed to update ${path}: ${err.message}`, err); } } /** * Deletes a file from the repository * @param {String} path - Path to the file * @param {String} message - Commit message * @param {String} branch - Branch name * @param {String} sha - SHA of the file * @returns {Promise&lt;Array&gt;} ResponseFactory result */ async deleteFile(path, message, branch, sha) { try { const response = await this.octokit.rest.repos.deleteFile({ owner: this.orgName, repo: this.repoName, path, message, branch, sha }); return ResponseFactory.success(`Deleted ${path}`, response.data); } catch (err) { return ResponseFactory.error(`Failed to delete ${path}: ${err.message}`, err); } } /** * Gets user information * @returns {Promise&lt;Array&gt;} ResponseFactory result */ async getUser() { try { const response = await this.octokit.rest.users.getAuthenticated(); return ResponseFactory.success('Successfully retrieved user information', response.data); } catch (err) { return ResponseFactory.error(`Failed to get user: ${err.message}`, err.message); } } /** * Gets all users (collaborators) for the repository * @returns {Promise&lt;Array&gt;} ResponseFactory result */ async getCollaborators() { try { const response = await this.octokit.rest.repos.listCollaborators({ owner: this.orgName, repo: this.repoName, affiliation: 'all' }); return ResponseFactory.success('Successfully retrieved collaborators', response.data); } catch (err) { return ResponseFactory.error(`Failed to get collaborators: ${err.message}`, err.message); } } /** * Gets billing information for GitHub Actions * @returns {Promise&lt;Array&gt;} ResponseFactory result */ async getActionsBilling() { try { const response = await this.octokit.rest.billing.getGithubActionsBillingOrg({ org: this.orgName, }); return ResponseFactory.success('Successfully retrieved actions billing', response.data); } catch (err) { return ResponseFactory.error(`Failed to get actions billing: ${err.message}`, err.message, 404); } } /** * Gets billing information for GitHub Storage * @returns {Promise&lt;Array&gt;} ResponseFactory result */ async getStorageBilling() { try { const response = await this.octokit.rest.billing.getSharedStorageBillingOrg({ org: this.orgName, }); return ResponseFactory.success('Successfully retrieved storage billing', response.data); } catch (err) { return ResponseFactory.error(`Failed to get storage billing: ${err.message}`, err.message, 404); } } /** * Creates a repository in the organization * @param {String} description - Repository description * @returns {Promise&lt;Array&gt;} ResponseFactory result */ async createRepository(description) { try { const response = await this.octokit.rest.repos.createInOrg({ org: this.orgName, name: this.repoName, description: description, private: true }); return ResponseFactory.success(`Created repository ${this.repoName}`, response.data); } catch (err) { return ResponseFactory.error(`Failed to create repository: ${err.message}`, err.message); } } /** * Gets organization information * @returns {Promise&lt;Array&gt;} ResponseFactory result */ async getOrganization() { try { const response = await this.octokit.rest.orgs.get({ org: this.orgName }); return ResponseFactory.success(`Retrieved organization ${this.orgName}`, response.data); } catch (err) { return ResponseFactory.error(`Failed to get organization: ${err.message}`, err.message); } } } export default RepositoryManager; × Search results Close "},"github_response.js.html":{"id":"github_response.js.html","title":"Source: github/response.js","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Source: github/response.js /** * @fileoverview Factory for creating standardized API responses * @license Apache-2.0 * @version 3.0.0 */ /** * Creates standardized API responses for GitHub operations */ class ResponseFactory { /** * Creates a success response * @param {String} message - Success message * @param {*} data - Response data * @param {Number} code - HTTP status code * @returns {Array} [true, {status_code, status_msg}, data] */ static success(message, data = null, code = 200) { return [true, { status_code: code, status_msg: message }, data]; } /** * Creates an error response * @param {String} message - Error message * @param {*} error - Error object or message * @param {Number} code - HTTP status code * @returns {Array} [false, {status_code, status_msg}, error] */ static error(message, error = null, code = 500) { return [false, { status_code: code, status_msg: message }, error]; } } export default ResponseFactory; × Search results Close "},"gitHubServer_schema.js.html":{"id":"gitHubServer_schema.js.html","title":"Source: gitHubServer/schema.js","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Source: gitHubServer/schema.js /** * Schema validation for entities */ // Add this import at the top of the file import { isEmpty, isArray } from '../../utils/helpers.js'; export class SchemaValidator { constructor(schemas = {}) { this.schemas = schemas; } /** * Add or update schema * @param {string} entityType - Entity type * @param {Object} schema - Schema definition */ setSchema(entityType, schema) { this.schemas[entityType] = schema; } /** * Validate object against schema * @param {string} entityType - Entity type * @param {Object} obj - Object to validate * @returns {Object} Validation result {valid, errors} */ validate(entityType, obj) { const schema = this.schemas[entityType]; if (!schema) { return { valid: true, errors: [] }; // No schema defined } const errors = []; // Check required fields if (schema.required) { for (const field of schema.required) { if (isEmpty(obj[field])) { errors.push(`Required field [${field}] is missing`); } } } // Check field types if (schema.properties) { for (const [field, def] of Object.entries(schema.properties)) { if (obj[field] !== undefined) { if (def.type === 'string' &amp;&amp; typeof obj[field] !== 'string') { errors.push(`Field [${field}] must be a string`); } else if (def.type === 'number' &amp;&amp; typeof obj[field] !== 'number') { errors.push(`Field [${field}] must be a number`); } else if (def.type === 'boolean' &amp;&amp; typeof obj[field] !== 'boolean') { errors.push(`Field [${field}] must be a boolean`); } else if (def.type === 'array' &amp;&amp; !isArray(obj[field])) { errors.push(`Field [${field}] must be an array`); } else if (def.type === 'object' &amp;&amp; (typeof obj[field] !== 'object' || obj[field] === null)) { errors.push(`Field [${field}] must be an object`); } // Check enum values if (def.enum &amp;&amp; !def.enum.includes(obj[field])) { errors.push(`Field [${field}] must be one of: ${def.enum.join(', ')}`); } // Check pattern if (def.pattern &amp;&amp; typeof obj[field] === 'string') { const regex = new RegExp(def.pattern); if (!regex.test(obj[field])) { errors.push(`Field [${field}] does not match required pattern`); } } } } } return { valid: errors.length === 0, errors }; } } // Define schemas const schemas = { Companies: { required: ['name'], properties: { name: { type: 'string' }, company_type: { type: 'string', enum: ['Public', 'Private', 'Non-profit', 'Government', 'Educational'] }, status: { type: 'string', enum: ['Active', 'Inactive', 'Acquired', 'Merged', 'Bankrupt'] }, url: { type: 'string', pattern: '^https?://.+' } // Other fields... } }, Interactions: { required: ['name'], properties: { name: { type: 'string' }, content_type: { type: 'string', enum: ['PDF', 'DOC', 'DOCX', 'TXT', 'HTML', 'PPT', 'PPTX', 'XLS', 'XLSX', 'CSV'] }, status: { type: 'string', enum: ['Draft', 'Published', 'Archived'] }, public: { type: 'boolean' } // Other fields... } }, Studies: { required: ['name'], properties: { name: { type: 'string' }, status: { type: 'string', enum: ['Active', 'Completed', 'Cancelled'] }, public: { type: 'boolean' } // Other fields... } } }; // Create and export validator instance export const validator = new SchemaValidator(schemas); × Search results Close "},"gitHubServer_entities_storage.js.html":{"id":"gitHubServer_entities_storage.js.html","title":"Source: gitHubServer/entities/storage.js","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Source: gitHubServer/entities/storage.js /* eslint-disable no-console */ /** * Storage entity class for GitHub repository storage operations * @file storage.js * @license Apache-2.0 * @version 3.0.0 * * @author Michael Hay &lt;michael.hay@mediumroast.io&gt; * @copyright 2024 Mediumroast, Inc. All rights reserved. */ import { BaseObjects } from '../baseObjects.js'; import { logger } from '../logger.js'; export class Storage extends BaseObjects { /** * @constructor * @param {string} token - GitHub API token * @param {string} org - GitHub organization name * @param {string} processName - Process name for locking */ constructor(token, org, processName) { super(token, org, processName, 'Storage'); // Add storage-specific cache keys this._cacheKeys.storageBilling = 'storage_billing'; this._cacheKeys.byContainer = 'storage_by_container'; this._cacheKeys.quota = 'storage_quota'; this._cacheKeys.trends = 'storage_trends'; // Set specific cache timeouts this.cacheTimeouts.storageBilling = 3600000; // 1 hour for billing info this.cacheTimeouts.byContainer = 3600000; // 1 hour for container info this.cacheTimeouts.quota = 86400000; // 24 hours for quota info this.cacheTimeouts.trends = 86400000; // 24 hours for trends // Define object file names for containers this.objectFiles = { Studies: 'studies.json', Companies: 'companies.json', Interactions: 'interactions.json' }; } /** * Get repository size information * @returns {Promise&lt;Array&gt;} Size information */ async getRepoSize() { // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'getRepoSize') : { end: () =&gt; {} }; try { return await this.cache.getOrFetch( this._cacheKeys.repoSize, async () =&gt; { try { // Try to use getRepository method first if (typeof this.serverCtl.getRepository === 'function') { const repoResponse = await this.serverCtl.getRepository(); if (!repoResponse[0]) { return repoResponse; } // Extract just the size from the response return this._createSuccess( 'Retrieved repository size successfully', repoResponse[2].size || 0 ); } // Try to use getRepoSize (older method name) as fallback else if (typeof this.serverCtl.getRepoSize === 'function') { logger.info('Using legacy getRepoSize method'); return await this.serverCtl.getRepoSize(); } // If neither method exists, provide a fallback response else { logger.warn('Repository size methods not implemented in github.js, using fallback'); return this._createSuccess( 'Repository size functionality not fully implemented', { size: 0, message: 'This is a placeholder. The getRepository method needs to be implemented in the github.js file.' } ); } } catch (error) { // Handle any unexpected errors logger.error('Failed to retrieve repository size', error); throw error; // Re-throw to be caught by outer try-catch } }, this.cacheTimeouts.repoSize || 3600000, [] // No dependencies ); } catch (error) { return this._createError( `Failed to retrieve repository size: ${error.message}`, error, 500 ); } finally { tracking.end(); } } /** * Get storage billing information * @returns {Promise&lt;Array&gt;} Storage billing info */ async getStorageBilling() { // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'getStorageBilling') : { end: () =&gt; {} }; try { return await this.cache.getOrFetch( this._cacheKeys.storageBilling, async () =&gt; { try { // Check if the method exists first if (typeof this.serverCtl.getStorageBillings === 'function') { return await this.serverCtl.getStorageBillings(); } else { // Provide fallback mock data logger.warn('getStorageBillings not implemented in github.js, using fallback'); return this._createSuccess( 'Storage billing functionality not fully implemented', { days_left_in_billing_cycle: 15, estimated_paid_storage_for_month: 0, estimated_storage_for_month: 5, message: 'This is a placeholder. The getStorageBillings method needs to be implemented.' } ); } } catch (error) { logger.error('Failed to retrieve storage billing', error); throw error; } }, this.cacheTimeouts.storageBilling, [] ); } catch (error) { return this._createError( `Failed to retrieve storage billing: ${error.message}`, error, 500 ); } finally { tracking.end(); } } /** * Get storage usage by container * @returns {Promise&lt;Array&gt;} Storage usage by container */ async getStorageByContainer() { // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'getStorageByContainer') : { end: () =&gt; {} }; try { return await this.cache.getOrFetch( this._cacheKeys.byContainer, async () =&gt; { try { // Get all container names const containers = ['Studies', 'Companies', 'Interactions']; const stats = { totalSize: 0, containers: {} }; for (const container of containers) { // Skip if no object file for this container if (!this.objectFiles[container]) { logger.debug(`Skipping container ${container} - no object file defined`); continue; } // Initialize container statistics stats.containers[container] = { size: 0, objectCount: 0, lastUpdated: null }; // Get container objects const containerClass = new BaseObjects( this.serverCtl.token, this.serverCtl.orgName, 'storage-analyzer', container ); const objectsResp = await containerClass.getAll(); if (!objectsResp[0]) { logger.warn(`Failed to get objects for ${container}: ${objectsResp[1]?.status_msg}`); continue; } const objects = objectsResp[2].mrJson; stats.containers[container].objectCount = objects.length; // Get latest modification date for (const obj of objects) { if (obj.modification_date &amp;&amp; (!stats.containers[container].lastUpdated || new Date(obj.modification_date) &gt; new Date(stats.containers[container].lastUpdated))) { stats.containers[container].lastUpdated = obj.modification_date; } } // For Interactions, also calculate total file size if (container === 'Interactions') { let totalInteractionSize = 0; for (const obj of objects) { if (obj.file_size) { totalInteractionSize += obj.file_size; } } stats.containers[container].fileSize = totalInteractionSize; } // Get container file size from SHA try { if (typeof this.serverCtl.getSha === 'function') { const shaResp = await this.serverCtl.getSha( container, this.objectFiles[container], 'main' ); if (shaResp[0] &amp;&amp; shaResp[2] &amp;&amp; typeof this.serverCtl.getContent === 'function') { const contentResp = await this.serverCtl.getContent( `${container}/${this.objectFiles[container]}`, 'main' ); if (contentResp[0] &amp;&amp; contentResp[2] &amp;&amp; contentResp[2].size) { stats.containers[container].size = contentResp[2].size; stats.totalSize += contentResp[2].size; } } } } catch (err) { logger.error(`Error getting size for ${container}:`, err); } } return this._createSuccess( 'Retrieved storage usage by container', stats ); } catch (err) { return this._createError( `Failed to retrieve storage usage: ${err.message}`, err, 500 ); } }, this.cacheTimeouts.byContainer, [] ); } finally { tracking.end(); } } /** * Get storage usage trends over time * @param {number} days - Number of days to analyze * @returns {Promise&lt;Array&gt;} Storage usage trends */ async getStorageTrends(days = 30) { // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'getStorageTrends') : { end: () =&gt; {} }; // Validate parameters const validationError = this._validateParams( { days }, { days: 'number' } ); if (validationError) return validationError; try { // Use cache with key that includes days parameter const trendsCacheKey = `${this._cacheKeys.trends}_${days}`; return await this.cache.getOrFetch( trendsCacheKey, async () =&gt; { try { const commitHistory = await this.serverCtl.getCommitHistory(days); if (!commitHistory[0]) { return commitHistory; } // Extract size information from commits const sizeByDate = {}; const commits = commitHistory[2]; for (const commit of commits) { const date = commit.commit.author.date.substring(0, 10); // YYYY-MM-DD // Get the repo size at this commit try { const sizeResp = await this.serverCtl.getRepoSizeAtCommit(commit.sha); if (sizeResp[0] &amp;&amp; sizeResp[2]) { sizeByDate[date] = sizeResp[2]; } } catch (err) { logger.error(`Error getting size at commit ${commit.sha}:`, err); } } // Convert to array and sort by date const trends = Object.entries(sizeByDate).map(([date, size]) =&gt; ({ date, size })).sort((a, b) =&gt; new Date(a.date) - new Date(b.date)); return this._createSuccess( `Retrieved storage trends for the past ${days} days`, trends ); } catch (err) { return this._createError( `Failed to retrieve storage trends: ${err.message}`, err, 500 ); } }, this.cacheTimeouts.trends ); } finally { tracking.end(); } } /** * Get storage quota and usage * @returns {Promise&lt;Array&gt;} Storage quota and usage information */ async getQuota() { // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'getQuota') : { end: () =&gt; {} }; try { return await this.cache.getOrFetch( this._cacheKeys.quota, async () =&gt; { try { if (typeof this.serverCtl.getGitHubOrg === 'function') { const orgResp = await this.serverCtl.getGitHubOrg(); if (!orgResp[0]) { return orgResp; } // Provide basic quota information const quota = { organization: this.org, plan: orgResp[2]?.plan || { name: 'unknown', space: 'unknown' } }; return this._createSuccess( 'Retrieved storage quota information', quota ); } else { // Provide fallback mock data return this._createSuccess( 'Storage quota functionality not fully implemented', { organization: this.org, plan: { name: 'team', space: 'unlimited', message: 'This is a placeholder. The getGitHubOrg method needs to be implemented.' } } ); } } catch (err) { return this._createError( `Failed to retrieve storage quota: ${err.message}`, err, 500 ); } }, this.cacheTimeouts.quota, [] ); } finally { tracking.end(); } } /** * Get disk usage analytics * @returns {Promise&lt;Array&gt;} Disk usage analytics */ async getDiskUsageAnalytics() { // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'getDiskUsageAnalytics') : { end: () =&gt; {} }; try { // Use cache with dependencies on container and repo size const analyticsCacheKey = 'storage_analytics'; return await this.cache.getOrFetch( analyticsCacheKey, async () =&gt; { try { // Get storage by container const containerResp = await this.getStorageByContainer(); if (!containerResp[0]) { return containerResp; } const storage = containerResp[2]; // Calculate analytics const analytics = { totalSize: storage.totalSize, repoSize: storage.repoSize || 0, containers: {}, percentages: {}, largestContainer: { name: '', size: 0 }, mostObjects: { name: '', count: 0 }, mostRecentActivity: { name: '', date: null } }; // Calculate container analytics for (const [name, container] of Object.entries(storage.containers)) { // Copy container data analytics.containers[name] = container; // Calculate percentage of total analytics.percentages[name] = storage.totalSize &gt; 0 ? (container.size / storage.totalSize) * 100 : 0; // Track largest container if (container.size &gt; analytics.largestContainer.size) { analytics.largestContainer = { name, size: container.size }; } // Track container with most objects if (container.objectCount &gt; analytics.mostObjects.count) { analytics.mostObjects = { name, count: container.objectCount }; } // Track most recent activity if (container.lastUpdated &amp;&amp; (!analytics.mostRecentActivity.date || new Date(container.lastUpdated) &gt; new Date(analytics.mostRecentActivity.date))) { analytics.mostRecentActivity = { name, date: container.lastUpdated }; } } // Add projected growth based on trends try { const trendsResp = await this.getStorageTrends(30); if (trendsResp[0] &amp;&amp; trendsResp[2] &amp;&amp; trendsResp[2].length &gt; 1) { const trends = trendsResp[2]; const firstSize = trends[0].size; const lastSize = trends[trends.length - 1].size; const growthRate = (lastSize - firstSize) / firstSize; analytics.growth = { rate: growthRate, period: '30 days', projectedSize: { '30days': Math.round(lastSize * (1 + growthRate)), '90days': Math.round(lastSize * Math.pow(1 + growthRate, 3)) } }; } } catch (err) { logger.warn('Failed to calculate growth projections', err); } return this._createSuccess( 'Generated storage analytics', analytics ); } catch (err) { return this._createError( `Failed to generate disk usage analytics: ${err.message}`, err, 500 ); } }, 300000, // 5 minutes cache [ this._cacheKeys.byContainer, // Depends on container data this._cacheKeys.trends, // Depends on trends data this._cacheKeys.repoSize // Depends on repo size ] ); } finally { tracking.end(); } } } × Search results Close "},"gitHubServer_entities_studies.js.html":{"id":"gitHubServer_entities_studies.js.html","title":"Source: gitHubServer/entities/studies.js","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Source: gitHubServer/entities/studies.js /** * @fileoverview Studies entity for GitHubServer * @license Apache-2.0 * @version 3.0.0 * * @author Michael Hay &lt;michael.hay@mediumroast.io&gt; * @copyright 2024 Mediumroast, Inc. All rights reserved. */ import { BaseObjects } from '../baseObjects.js'; import { logger } from '../logger.js'; export class Studies extends BaseObjects { /** * @constructor * @param {string} token - GitHub API token * @param {string} org - GitHub organization name * @param {string} processName - Process name for locking */ constructor(token, org, processName) { super(token, org, processName, 'Studies'); // Add studies-specific cache keys this._cacheKeys.byStatus = `${this.objType}_byStatus`; this._cacheKeys.byAccess = `${this.objType}_byAccess`; this._cacheKeys.byGroup = `${this.objType}_byGroup`; this._cacheKeys.summary = `${this.objType}_summary`; } /** * Delete a study * @param {string} objName - Study name to delete * @returns {Promise&lt;Array&gt;} Operation result */ async deleteObj(objName) { // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'deleteObj') : { end: () =&gt; {} }; try { // Validate parameter const validationError = this._validateParams( { objName }, { objName: 'string' } ); if (validationError) return validationError; const source = { from: 'Studies', to: ['Companies', 'Interactions'] }; return await this._executeTransaction([ // Step 1: Catch containers async () =&gt; { let repoMetadata = { containers: { Studies: {}, Companies: {}, Interactions: {} }, branch: {} }; return this.serverCtl.catchContainer(repoMetadata); }, // Step 2: Get study info async (data) =&gt; { const studyObj = await this.findByX('name', objName, data.containers.Studies.objects); if (!studyObj[0]) { return studyObj; // Will abort transaction } // Store linked objects for later steps this._tempStudy = studyObj[2][0]; return this._createSuccess('Found study'); }, // Step 3: Delete study async (data) =&gt; { const deleteResult = await this.serverCtl.deleteObject( objName, source, data, false ); if (!deleteResult[0]) { return deleteResult; // Will abort transaction } return this._createSuccess('Deleted study object'); }, // Step 4: Release containers async (data) =&gt; { const result = await this.serverCtl.releaseContainer(data); if (result[0]) { // Invalidate all related caches this._invalidateCache(); // Also invalidate related entities' caches this.cache.invalidate('container_Companies'); this.cache.invalidate('container_Interactions'); if (this.serverCtl.invalidateCache) { this.serverCtl.invalidateCache('container_Companies'); this.serverCtl.invalidateCache('container_Interactions'); } } return result; } ], `delete-study-${objName}`); } finally { tracking.end(); } } /** * Find studies by status * @param {string} status - Status to search for * @returns {Promise&lt;Array&gt;} Search results */ async findByStatus(status) { // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'findByStatus') : { end: () =&gt; {} }; try { // Validate parameter const validationError = this._validateParams( { status }, { status: 'string' } ); if (validationError) return validationError; // Use cache with dependency on container data const statusCacheKey = `${this._cacheKeys.byStatus}_${status}`; return await this.cache.getOrFetch( statusCacheKey, () =&gt; this.findByX('status', status), this.cacheTimeouts[this.objType] || 300000, [this._cacheKeys.container] // Depends on all studies ); } finally { tracking.end(); } } /** * Find studies by access type (public or private) * @param {boolean} isPublic - Whether to find public studies * @returns {Promise&lt;Array&gt;} Search results */ async findByAccess(isPublic) { // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'findByAccess') : { end: () =&gt; {} }; try { // Validate parameter (as boolean) if (typeof isPublic !== 'boolean') { return this._createError('isPublic parameter must be a boolean', null, 400); } // Use cache with dependency on container data const accessCacheKey = `${this._cacheKeys.byAccess}_${isPublic}`; return await this.cache.getOrFetch( accessCacheKey, () =&gt; this.findByX('public', isPublic), this.cacheTimeouts[this.objType] || 300000, [this._cacheKeys.container] // Depends on all studies ); } finally { tracking.end(); } } /** * Find studies by group * @param {string} group - Group name to search for * @returns {Promise&lt;Array&gt;} Search results */ async findByGroup(group) { // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'findByGroup') : { end: () =&gt; {} }; try { // Validate parameter const validationError = this._validateParams( { group }, { group: 'string' } ); if (validationError) return validationError; // Use cache with dependency on container data const groupCacheKey = `${this._cacheKeys.byGroup}_${group}`; return await this.cache.getOrFetch( groupCacheKey, async () =&gt; { // Get all studies const allStudiesResp = await this.getAll(); if (!allStudiesResp[0]) { return allStudiesResp; } const allStudies = allStudiesResp[2].mrJson; // Filter studies by group membership const results = allStudies.filter(study =&gt; study.groups &amp;&amp; study.groups.includes(group) ); if (results.length === 0) { return this._createError( `No studies found in group [${group}]`, null, 404 ); } return this._createSuccess( `Found ${results.length} studies in group [${group}]`, results ); }, this.cacheTimeouts[this.objType] || 300000, [this._cacheKeys.container] // Depends on all studies ); } catch (error) { return this._createError( `Error finding studies by group: ${error.message}`, error, 500 ); } finally { tracking.end(); } } /** * Adds an entity to a study * @param {string} studyName - Study name * @param {string} entityType - Entity type ('Interactions' or 'Companies') * @param {string} entityName - Entity name to add * @returns {Promise&lt;Array&gt;} Operation result */ async addToStudy(studyName, entityType, entityName) { // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'addToStudy') : { end: () =&gt; {} }; try { // Validate parameters const validationError = this._validateParams( { studyName, entityType, entityName }, { studyName: 'string', entityType: 'string', entityName: 'string' } ); if (validationError) return validationError; // Additional validation for entityType if (!['Interactions', 'Companies'].includes(entityType)) { return this._createError( `Invalid entity type: [${entityType}]. Must be 'Interactions' or 'Companies'`, null, 400 ); } return await this._executeTransaction([ // Step 1: Catch containers async () =&gt; { let repoMetadata = { containers: { Studies: {}, [entityType]: {} }, branch: {} }; return this.serverCtl.catchContainer(repoMetadata); }, // Step 2: Find study and entity async (data) =&gt; { // Find study const studyResp = await this.findByX('name', studyName, data.containers.Studies.objects); if (!studyResp[0]) { return studyResp; } // Find entity const entityClass = new BaseObjects( this.serverCtl.token, this.serverCtl.orgName, 'study-manager', entityType ); const entityResp = await entityClass.findByX( 'name', entityName, data.containers[entityType].objects ); if (!entityResp[0]) { return this._createError( `${entityType} with name [${entityName}] not found`, null, 404 ); } // Store for next step this._tempStudy = studyResp[2][0]; this._tempEntity = entityResp[2][0]; return this._createSuccess('Found study and entity'); }, // Step 3: Update study async (data) =&gt; { // Initialize linked entities field if needed const fieldName = `linked_${entityType.toLowerCase()}`; if (!this._tempStudy[fieldName]) { this._tempStudy[fieldName] = {}; } // Add entity to study this._tempStudy[fieldName][entityName] = { linked_date: new Date().toISOString() }; // Update study modification date this._tempStudy.modification_date = new Date().toISOString(); // Update the study object in the container for (let i = 0; i &lt; data.containers.Studies.objects.length; i++) { if (data.containers.Studies.objects[i].name === studyName) { data.containers.Studies.objects[i] = this._tempStudy; break; } } return this._createSuccess('Updated study with link to entity'); }, // Step 4: Update entity to reference study async (data) =&gt; { // Add study reference to entity const fieldName = 'linked_studies'; if (!this._tempEntity[fieldName]) { this._tempEntity[fieldName] = {}; } // Add study to entity this._tempEntity[fieldName][studyName] = { linked_date: new Date().toISOString() }; // Update entity modification date this._tempEntity.modification_date = new Date().toISOString(); // Update the entity object in the container for (let i = 0; i &lt; data.containers[entityType].objects.length; i++) { if (data.containers[entityType].objects[i].name === entityName) { data.containers[entityType].objects[i] = this._tempEntity; break; } } return this._createSuccess('Updated entity with link to study'); }, // Step 5: Write study container async (data) =&gt; { const studySha = await this.serverCtl.getSha( 'Studies', this.objectFiles.Studies, data.branch.name ); if (!studySha[0]) { return studySha; } return await this.serverCtl.writeObject( 'Studies', data.containers.Studies.objects, data.branch.name, studySha[2] ); }, // Step 6: Write entity container async (data) =&gt; { const entitySha = await this.serverCtl.getSha( entityType, this.objectFiles[entityType], data.branch.name ); if (!entitySha[0]) { return entitySha; } return await this.serverCtl.writeObject( entityType, data.containers[entityType].objects, data.branch.name, entitySha[2] ); }, // Step 7: Release containers async (data) =&gt; { const result = await this.serverCtl.releaseContainer(data); if (result[0]) { // Invalidate related caches this._invalidateCache(); // Also invalidate the other entity's cache this.cache.invalidate(`container_${entityType}`); if (this.serverCtl.invalidateCache) { this.serverCtl.invalidateCache(`container_${entityType}`); } } return result; } ], `add-to-study-${studyName}-${entityName}`); } catch (error) { return this._createError( `Error adding entity to study: ${error.message}`, error, 500 ); } finally { tracking.end(); } } /** * Gets a study summary with statistics * @param {string} studyName - Study name * @returns {Promise&lt;Array&gt;} Study summary */ async getStudySummary(studyName) { // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'getStudySummary') : { end: () =&gt; {} }; try { // Validate parameter const validationError = this._validateParams( { studyName }, { studyName: 'string' } ); if (validationError) return validationError; // Use cache with dependencies on multiple containers const summaryCacheKey = `${this._cacheKeys.summary}_${studyName}`; return await this.cache.getOrFetch( summaryCacheKey, async () =&gt; { const studyResp = await this.findByName(studyName); if (!studyResp[0]) { return studyResp; } const study = studyResp[2][0]; // Prepare summary statistics const summary = { name: study.name, description: study.description, status: study.status, creation_date: study.creation_date, modification_date: study.modification_date, statistics: { companies: { count: study.linked_companies ? Object.keys(study.linked_companies).length : 0, items: [] }, interactions: { count: study.linked_interactions ? Object.keys(study.linked_interactions).length : 0, byType: {}, items: [] }, recentActivity: null } }; // Track most recent activity if (study.modification_date) { summary.statistics.recentActivity = study.modification_date; } // If there are linked companies, get their details if (study.linked_companies &amp;&amp; Object.keys(study.linked_companies).length &gt; 0) { const companiesClass = new BaseObjects( this.serverCtl.token, this.serverCtl.orgName, 'study-summarizer', 'Companies' ); const allCompaniesResp = await companiesClass.getAll(); if (allCompaniesResp[0]) { const allCompanies = allCompaniesResp[2].mrJson; // Find companies linked to this study Object.keys(study.linked_companies).forEach(companyName =&gt; { const company = allCompanies.find(c =&gt; c.name === companyName); if (company) { summary.statistics.companies.items.push({ name: company.name, description: company.description, company_type: company.company_type, linkedDate: study.linked_companies[companyName].linked_date }); // Update recent activity if company was modified more recently if (company.modification_date &amp;&amp; (!summary.statistics.recentActivity || new Date(company.modification_date) &gt; new Date(summary.statistics.recentActivity))) { summary.statistics.recentActivity = company.modification_date; } } }); } } // If there are linked interactions, get their details if (study.linked_interactions &amp;&amp; Object.keys(study.linked_interactions).length &gt; 0) { const interactionsClass = new BaseObjects( this.serverCtl.token, this.serverCtl.orgName, 'study-summarizer', 'Interactions' ); const allInteractionsResp = await interactionsClass.getAll(); if (allInteractionsResp[0]) { const allInteractions = allInteractionsResp[2].mrJson; // Find interactions linked to this study Object.keys(study.linked_interactions).forEach(interactionName =&gt; { const interaction = allInteractions.find(i =&gt; i.name === interactionName); if (interaction) { // Track by content type if (interaction.content_type) { summary.statistics.interactions.byType[interaction.content_type] = (summary.statistics.interactions.byType[interaction.content_type] || 0) + 1; } summary.statistics.interactions.items.push({ name: interaction.name, description: interaction.description, content_type: interaction.content_type, file_size: interaction.file_size, linkedDate: study.linked_interactions[interactionName].linked_date }); // Update recent activity if interaction was modified more recently if (interaction.modification_date &amp;&amp; (!summary.statistics.recentActivity || new Date(interaction.modification_date) &gt; new Date(summary.statistics.recentActivity))) { summary.statistics.recentActivity = interaction.modification_date; } } }); } } return this._createSuccess( `Generated summary for study [${studyName}]`, summary ); }, 600000, // Cache for 10 minutes [ this._cacheKeys.container, // Depends on studies data 'container_Companies', // Depends on companies data 'container_Interactions' // Depends on interactions data ] ); } catch (error) { return this._createError( `Error generating study summary: ${error.message}`, error, 500 ); } finally { tracking.end(); } } /** * Create a new study * @param {Object} studyData - Study data * @returns {Promise&lt;Array&gt;} Operation result */ async createStudy(studyData) { // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'createStudy') : { end: () =&gt; {} }; try { // Validate parameter const validationError = this._validateParams( { studyData }, { studyData: 'object' } ); if (validationError) return validationError; // Ensure name is present if (!studyData.name || typeof studyData.name !== 'string' || !studyData.name.trim()) { return this._createError('Study name is required', null, 400); } // Set default values if not provided const now = new Date().toISOString(); const study = { name: studyData.name, description: studyData.description || '', status: studyData.status || 'active', public: studyData.public !== undefined ? studyData.public : false, groups: Array.isArray(studyData.groups) ? studyData.groups : [], creation_date: now, modification_date: now }; // Create the study using the base createObj method return await this.createObj([study]); } catch (error) { return this._createError( `Error creating study: ${error.message}`, error, 500 ); } finally { tracking.end(); } } } × Search results Close "},"github_user.js.html":{"id":"github_user.js.html","title":"Source: github/user.js","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Source: github/user.js /** * @fileoverview User management operations for GitHub * @license Apache-2.0 * @version 3.0.0 */ import ResponseFactory from './response.js'; /** * Manages GitHub user operations */ class UserManager { /** * @constructor * @param {Object} octokit - Octokit instance * @param {String} orgName - GitHub organization name * @param {String} repoName - GitHub repository name */ constructor(octokit, orgName, repoName) { this.octokit = octokit; this.orgName = orgName; this.repoName = repoName; } /** * Gets the authenticated user from the GitHub API * @returns {Promise&lt;Array&gt;} ResponseFactory result */ async getCurrentUser() { try { const response = await this.octokit.rest.users.getAuthenticated(); return ResponseFactory.success( `Successfully retrieved authenticated user information`, response.data ); } catch (err) { return ResponseFactory.error( `Failed to retrieve authenticated user: ${err.message}`, err ); } } /** * Gets all users (collaborators) from the repository * @returns {Promise&lt;Array&gt;} ResponseFactory result */ async getAllUsers() { try { const response = await this.octokit.rest.repos.listCollaborators({ owner: this.orgName, repo: this.repoName, affiliation: 'all' }); return ResponseFactory.success( `Successfully retrieved all repository collaborators`, response.data ); } catch (err) { return ResponseFactory.error( `Failed to retrieve repository collaborators: ${err.message}`, err ); } } /** * Adds a user to the repository with specified permissions * @param {String} username - GitHub username to add * @param {String} permission - Permission level ('pull', 'push', 'admin', 'maintain', 'triage') * @returns {Promise&lt;Array&gt;} ResponseFactory result */ async addUserToRepository(username, permission = 'pull') { try { const response = await this.octokit.rest.repos.addCollaborator({ owner: this.orgName, repo: this.repoName, username: username, permission: permission }); return ResponseFactory.success( `Successfully added user ${username} to repository with ${permission} permissions`, response.data ); } catch (err) { return ResponseFactory.error( `Failed to add user ${username} to repository: ${err.message}`, err ); } } /** * Removes a user from the repository * @param {String} username - GitHub username to remove * @returns {Promise&lt;Array&gt;} ResponseFactory result */ async removeUserFromRepository(username) { try { const response = await this.octokit.rest.repos.removeCollaborator({ owner: this.orgName, repo: this.repoName, username: username }); return ResponseFactory.success( `Successfully removed user ${username} from repository`, response.data ); } catch (err) { return ResponseFactory.error( `Failed to remove user ${username} from repository: ${err.message}`, err ); } } } export default UserManager; × Search results Close "},"gitHubServer_entities_users.js.html":{"id":"gitHubServer_entities_users.js.html","title":"Source: gitHubServer/entities/users.js","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Source: gitHubServer/entities/users.js /** * @fileoverview Users entity for GitHubServer * @license Apache-2.0 * @version 3.0.0 * * @author Michael Hay &lt;michael.hay@mediumroast.io&gt; * @copyright 2024 Mediumroast, Inc. All rights reserved. */ import { BaseObjects } from '../baseObjects.js'; import { logger } from '../logger.js'; export class Users extends BaseObjects { /** * @constructor * @param {string} token - GitHub API token * @param {string} org - GitHub organization name * @param {string} processName - Process name for locking */ constructor(token, org, processName) { super(token, org, processName, 'Users'); // Add users-specific cache keys this._cacheKeys.allUsers = 'all_users'; this._cacheKeys.authUser = 'auth_user'; this._cacheKeys.byLogin = `${this.objType}_byLogin`; this._cacheKeys.byRole = `${this.objType}_byRole`; this._cacheKeys.userActivity = `${this.objType}_activity`; this._cacheKeys.orgActivity = 'org_activity'; // Set specific cache timeouts this.cacheTimeouts.userDetails = 600000; // 10 minutes for user details this.cacheTimeouts.authUser = 900000; // 15 minutes for auth user this.cacheTimeouts.activity = 300000; // 5 minutes for activity data } /** * Get all users with enhanced caching * @returns {Promise&lt;Array&gt;} List of users */ async getAll() { // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'getAll') : { end: () =&gt; {} }; try { return await this.cache.getOrFetch( this._cacheKeys.allUsers, async () =&gt; this.serverCtl.getAllUsers(), this.cacheTimeouts.userDetails || 600000, [] // No dependencies ); } catch (error) { return this._createError( `Failed to retrieve users: ${error.message}`, error, 500 ); } finally { tracking.end(); } } /** * Get the authenticated user * @returns {Promise&lt;Array&gt;} User information */ async getAuthenticatedUser() { // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'getAuthenticatedUser') : { end: () =&gt; {} }; try { return await this.cache.getOrFetch( this._cacheKeys.authUser, async () =&gt; this.serverCtl.getUser(), this.cacheTimeouts.authUser || 900000, [] // No dependencies ); } catch (error) { return this._createError( `Failed to retrieve authenticated user: ${error.message}`, error, 500 ); } finally { tracking.end(); } } /** * Find user by username/login * @param {string} login - GitHub username * @returns {Promise&lt;Array&gt;} User information */ async findByLogin(login) { // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'findByLogin') : { end: () =&gt; {} }; try { // Validate parameter const validationError = this._validateParams( { login }, { login: 'string' } ); if (validationError) return validationError; // Use cache with dependency on all users const loginCacheKey = `${this._cacheKeys.byLogin}_${login}`; return await this.cache.getOrFetch( loginCacheKey, async () =&gt; { // Get all users const allUsersResp = await this.getAll(); if (!allUsersResp[0]) { return allUsersResp; } // Find user with matching login const user = allUsersResp[2].find(u =&gt; u.login === login); if (!user) { return this._createError( `User with login [${login}] not found`, null, 404 ); } return this._createSuccess( `Found user with login [${login}]`, user ); }, this.cacheTimeouts.userDetails || 600000, [this._cacheKeys.allUsers] // Depends on all users ); } catch (error) { return this._createError( `Error finding user: ${error.message}`, error, 500 ); } finally { tracking.end(); } } /** * Find user by role * @param {string} role - Role to search for * @returns {Promise&lt;Array&gt;} User information */ async findByRole(role) { // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'findByRole') : { end: () =&gt; {} }; try { // Validate parameter const validationError = this._validateParams( { role }, { role: 'string' } ); if (validationError) return validationError; // Use cache with dependency on all users const roleCacheKey = `${this._cacheKeys.byRole}_${role}`; return await this.cache.getOrFetch( roleCacheKey, async () =&gt; { // Get all users const allUsersResp = await this.getAll(); if (!allUsersResp[0]) { return allUsersResp; } // Find users with matching role const users = allUsersResp[2].filter(u =&gt; u.role === role); if (users.length === 0) { return this._createError( `No users found with role [${role}]`, null, 404 ); } return this._createSuccess( `Found ${users.length} users with role [${role}]`, users ); }, this.cacheTimeouts.userDetails || 600000, [this._cacheKeys.allUsers] // Depends on all users ); } catch (error) { return this._createError( `Error finding users by role: ${error.message}`, error, 500 ); } finally { tracking.end(); } } /** * Update user role * @param {string} login - GitHub username * @param {string} newRole - New role to assign * @returns {Promise&lt;Array&gt;} Operation result */ async updateUserRole(login, newRole) { // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'updateUserRole') : { end: () =&gt; {} }; try { // Validate parameters const validationError = this._validateParams( { login, newRole }, { login: 'string', newRole: 'string' } ); if (validationError) return validationError; // Additional validation for role values const validRoles = ['admin', 'member', 'billing_manager']; if (!validRoles.includes(newRole)) { return this._createError( `Invalid role: [${newRole}]. Must be one of: ${validRoles.join(', ')}`, null, 400 ); } // Update the user's role const result = await this.serverCtl.updateOrgMembership(login, newRole); if (result[0]) { // Invalidate user caches this.cache.invalidate(this._cacheKeys.allUsers); this.cache.invalidate(`${this._cacheKeys.byLogin}_${login}`); // Invalidate all role caches as they may have changed validRoles.forEach(role =&gt; { this.cache.invalidate(`${this._cacheKeys.byRole}_${role}`); }); } return result; } catch (error) { return this._createError( `Failed to update user role: ${error.message}`, error, 500 ); } finally { tracking.end(); } } /** * Get user activity metrics * @param {string} login - GitHub username (optional) * @returns {Promise&lt;Array&gt;} User activity metrics */ async getUserActivity(login = null) { // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'getUserActivity') : { end: () =&gt; {} }; try { // If login provided, get metrics for specific user if (login) { // Validate parameter const validationError = this._validateParams( { login }, { login: 'string' } ); if (validationError) return validationError; // Use cache with specific user activity key const userActivityKey = `${this._cacheKeys.userActivity}_${login}`; return await this.cache.getOrFetch( userActivityKey, async () =&gt; { // Find the user first const userResp = await this.findByLogin(login); if (!userResp[0]) { return userResp; } const activityResp = await this.serverCtl.getUserActivity(login); if (!activityResp[0]) { return activityResp; } return this._createSuccess( `Retrieved activity for user [${login}]`, activityResp[2] ); }, this.cacheTimeouts.activity || 300000, [`${this._cacheKeys.byLogin}_${login}`] // Depends on user data ); } else { // Get metrics for all users return await this.cache.getOrFetch( this._cacheKeys.orgActivity, async () =&gt; { const allUsersResp = await this.getAll(); if (!allUsersResp[0]) { return allUsersResp; } const orgActivityResp = await this.serverCtl.getOrgActivity(); if (!orgActivityResp[0]) { return orgActivityResp; } return this._createSuccess( 'Retrieved organization activity metrics', orgActivityResp[2] ); }, this.cacheTimeouts.activity || 300000, [this._cacheKeys.allUsers] // Depends on all users ); } } catch (error) { return this._createError( `Error retrieving activity metrics: ${error.message}`, error, 500 ); } finally { tracking.end(); } } /** * Invite a new user to the organization * @param {string} email - User email * @param {string} role - Role to assign (admin, member, billing_manager) * @returns {Promise&lt;Array&gt;} Operation result */ async inviteUser(email, role = 'member') { // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'inviteUser') : { end: () =&gt; {} }; try { // Validate parameters const validationError = this._validateParams( { email, role }, { email: 'string', role: 'string' } ); if (validationError) return validationError; // Additional validation if (!email.includes('@')) { return this._createError('Invalid email format', null, 400); } // Check role validity const validRoles = ['admin', 'member', 'billing_manager']; if (!validRoles.includes(role)) { return this._createError( `Invalid role: [${role}]. Must be one of: ${validRoles.join(', ')}`, null, 400 ); } const result = await this.serverCtl.inviteOrgMember(email, role); if (result[0]) { // Invalidate user caches on success this.cache.invalidate(this._cacheKeys.allUsers); this.cache.invalidate(`${this._cacheKeys.byRole}_${role}`); } return result; } catch (error) { return this._createError( `Failed to invite user: ${error.message}`, error, 500 ); } finally { tracking.end(); } } /** * Remove a user from the organization * @param {string} login - GitHub username * @returns {Promise&lt;Array&gt;} Operation result */ async removeUser(login) { // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'removeUser') : { end: () =&gt; {} }; try { // Validate parameter const validationError = this._validateParams( { login }, { login: 'string' } ); if (validationError) return validationError; // Find user to get their current role before removal const userResp = await this.findByLogin(login); let userRole = null; if (userResp[0] &amp;&amp; userResp[2] &amp;&amp; userResp[2].role) { userRole = userResp[2].role; } const result = await this.serverCtl.removeOrgMember(login); if (result[0]) { // Invalidate user caches on success this.cache.invalidate(this._cacheKeys.allUsers); this.cache.invalidate(`${this._cacheKeys.byLogin}_${login}`); // Also invalidate role cache if we knew the user's role if (userRole) { this.cache.invalidate(`${this._cacheKeys.byRole}_${userRole}`); } else { // If we don't know the role, invalidate all role caches this.cache.invalidate(`${this._cacheKeys.byRole}_admin`); this.cache.invalidate(`${this._cacheKeys.byRole}_member`); this.cache.invalidate(`${this._cacheKeys.byRole}_billing_manager`); } } return result; } catch (error) { return this._createError( `Failed to remove user: ${error.message}`, error, 500 ); } finally { tracking.end(); } } } × Search results Close "},"gitHubServer.js.html":{"id":"gitHubServer.js.html","title":"Source: gitHubServer.js","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Source: gitHubServer.js /** * A class for authenticating and talking to the mediumroast.io backend * @author Michael Hay &lt;michael.hay@mediumroast.io&gt; * @file gitHubServer.js * @copyright 2024 Mediumroast, Inc. All rights reserved. * @license Apache-2.0 * @version 3.0.0 * * @exports {Studies, Companies, Interactions, Users, Storage, Actions} */ // Simply re-export everything from the index.js export * from './gitHubServer/index.js'; × Search results Close "},"gitHubServer_baseObjects.js.html":{"id":"gitHubServer_baseObjects.js.html","title":"Source: gitHubServer/baseObjects.js","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Source: gitHubServer/baseObjects.js /** * Base class for objects in the mediumroast.io backend * @author Michael Hay &lt;michael.hay@mediumroast.io&gt; * @file baseObjects.js * @copyright 2025 Mediumroast, Inc. All rights reserved. * @license Apache-2.0 * @version 3.0.0 * * @exports BaseObjects */ // Import required modules import GitHub from '../github.js'; import { isEmpty, isArray, deepClone } from '../../utils/helpers.js'; import { CacheManager } from './cache.js'; import { logger } from './logger.js'; import { createHash } from 'crypto'; import { Octokit } from '@octokit/core'; // Create a singleton cache instance for shared caching // const sharedCache = new CacheManager(); export class BaseObjects { /** * @constructor * @param {string} token - GitHub API token * @param {string} org - GitHub organization name * @param {string} processName - Process name for locking * @param {string} objType - Object type */ constructor(token, org, processName, objType) { this.token = token; this.org = org; this.processName = processName; this.objType = objType || 'BaseObject'; // Initialize GitHub API client this.serverCtl = new GitHub(this.token, this.org); // Initialize cache manager this.cache = new CacheManager(); // Initialize cache keys - must do this before adding specialized keys this._cacheKeys = { all: `${this.objType}_all`, byName: `${this.objType}_by_name`, byAttribute: `${this.objType}_by_attribute`, }; // Initialize cache timeouts this.cacheTimeouts = { all: 300000, // 5 minutes for all objects byName: 300000, // 5 minutes for specific objects byAttribute: 300000, // 5 minutes for attribute queries }; // Define object file names for containers this.objectFiles = { Studies: 'studies.json', Companies: 'companies.json', Interactions: 'interactions.json', Users: 'users.json' // Add users even though GitHub API doesn't store it the same way }; // Define field whitelists centrally this.whitelists = { Companies: [ 'description', 'company_type', 'url', 'role', 'wikipedia_url', 'status', 'logo_url', 'region', 'country', 'city', 'state_province', 'zip_postal', 'street_address', 'latitude', 'longitude', 'phone', 'google_maps_url', 'google_news_url', 'google_finance_url', 'google_patents_url', 'cik', 'stock_symbol', 'stock_exchange', 'recent_10k_url', 'recent_10q_url', 'firmographic_url', 'filings_url', 'owner_tranasactions', 'industry', 'industry_code', 'industry_group_code', 'industry_group_description', 'major_group_code', 'major_group_description' ], Interactions: [ 'status', 'content_type', 'file_size', 'reading_time', 'word_count', 'page_count', 'description', 'abstract', 'region', 'country', 'city', 'state_province', 'zip_postal', 'street_address', 'latitude', 'longitude', 'public', 'groups' ], Studies: [ 'description', 'status', 'public', 'groups' ] }; // For transaction tracking this._transactionDepth = 0; // Set up cache key naming this._cacheKeys = { container: `container_${this.objType}`, search: `search_${this.objType}`, byName: `${this.objType}_byName`, byAttribute: `${this.objType}_byAttribute` }; // Log initialization logger.debug(`Initialized ${objType} with org: ${org}`); } /** * Invalidate cache entries when data is modified * @private */ _invalidateCache() { // Invalidate the main container cache which will cascade to all dependent caches this.cache.invalidate(this._cacheKeys.container); // Also forward to github.js cache invalidation if it exists if (this.serverCtl.invalidateCache) { this.serverCtl.invalidateCache(this._cacheKeys.container); } logger.debug(`Cache invalidated for ${this.objType}`); } /** * Creates a standardized error response * @private * @param {String} message - Error message * @param {Object} data - Error data * @param {Number} statusCode - HTTP status code * @returns {Array} Standardized error response */ _createError(message, data = null, statusCode = 400) { logger.error(message, { data, statusCode }); return [false, { status_code: statusCode, status_msg: message }, data]; } /** * Creates a standardized success response * @private * @param {String} message - Success message * @param {Object} data - Response data * @param {Number} statusCode - HTTP status code * @returns {Array} Standardized success response */ _createSuccess(message, data = null, statusCode = 200) { logger.debug(message); return [true, { status_code: statusCode, status_msg: message }, data]; } /** * Validates parameters against expected types * @private * @param {Object} params - Parameters to validate * @param {Object} expectedTypes - Expected types for each parameter * @returns {Array|null} Error response or null if valid */ _validateParams(params, expectedTypes) { for (const [name, value] of Object.entries(params)) { const expectedType = expectedTypes[name]; if (!expectedType) continue; if (expectedType === 'array') { if (!isArray(value)) { return this._createError(`Invalid parameter: [${name}] must be an array`, null, 400); } } else if (expectedType === 'object') { if (typeof value !== 'object' || value === null) { return this._createError(`Invalid parameter: [${name}] must be an object`, null, 400); } } else if (expectedType === 'string') { if (typeof value !== 'string' || isEmpty(value)) { return this._createError(`Invalid parameter: [${name}] must be a non-empty string`, null, 400); } } else if (expectedType === 'boolean' &amp;&amp; typeof value !== 'boolean') { return this._createError(`Invalid parameter: [${name}] must be a boolean`, null, 400); } } return null; // No validation errors } /** * Executes a series of operations as a transaction * @private * @param {Array&lt;Function&gt;} operations - Array of async functions to execute * @param {String} transactionName - Name of the transaction for logging * @returns {Promise&lt;Array&gt;} Result of the transaction */ async _executeTransaction(operations, transactionName) { this._transactionDepth++; const transactionId = `${transactionName}-${Date.now()}-${this._transactionDepth}`; let results = []; // Track the transaction const tracking = logger.trackTransaction ? logger.trackTransaction(transactionName) : { end: () =&gt; {} }; try { for (let i = 0; i &lt; operations.length; i++) { const operation = operations[i]; const operationName = operation.name || `Step${i+1}`; try { // Pass accumulated data to each operation const result = await operation(i &gt; 0 ? results[i-1][2] : null); results.push(result); if (!result[0]) { // Operation failed, abort transaction return this._createError( `Transaction [${transactionName}] failed at step [${operationName}]: ${result[1].status_msg}`, { transactionId, failedStep: operationName, stepResult: result, completedSteps: i }, result[1].status_code || 500 ); } } catch (err) { return this._createError( `Transaction [${transactionName}] failed at step [${operationName}]: ${err.message}`, { transactionId, failedStep: operationName, error: err, completedSteps: i }, 500 ); } } // All operations succeeded return this._createSuccess( `Transaction [${transactionName}] completed successfully`, results[results.length - 1][2] ); } finally { this._transactionDepth--; tracking.end(); } } /** * Enhanced search functionality with better filtering options * @param {Object} filters - Filter criteria * @param {Object} options - Search options (limit, sort, etc) * @returns {Promise&lt;Array&gt;} Search results */ async search(filters = {}, options = { limit: 0, sort: null, descending: false }) { // Create a cache key based on filters and options const filterKey = JSON.stringify(filters); const optionsKey = JSON.stringify(options); const cacheKey = `${this._cacheKeys.search}_${filterKey}_${optionsKey}`; // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'search') : { end: () =&gt; {} }; try { // Use the cache with dependencies to the container return await this.cache.getOrFetch( cacheKey, async () =&gt; { // Get all objects const allObjectsResp = await this.getAll(); if (!allObjectsResp[0]) { return allObjectsResp; } const allObjects = allObjectsResp[2].mrJson; if (allObjects.length === 0) { return this._createError( `No ${this.objType} found`, null, 404 ); } // Apply filters let results = [...allObjects]; for (const [field, value] of Object.entries(filters)) { results = results.filter(obj =&gt; { if (field === 'name' &amp;&amp; typeof value === 'string') { return obj.name.toLowerCase().includes(value.toLowerCase()); } return obj[field] === value; }); } // Apply sorting if (options.sort &amp;&amp; results.length &gt; 0) { const sortField = options.sort; results.sort((a, b) =&gt; { if (!a[sortField]) return 1; if (!b[sortField]) return -1; if (typeof a[sortField] === 'string') { return options.descending ? b[sortField].localeCompare(a[sortField]) : a[sortField].localeCompare(b[sortField]); } return options.descending ? b[sortField] - a[sortField] : a[sortField] - b[sortField]; }); } // Apply limit if (options.limit &gt; 0) { results = results.slice(0, options.limit); } return this._createSuccess( `Found ${results.length} ${this.objType}`, results ); }, this.cacheTimeouts[this.objType] || 60000, [this._cacheKeys.container] // This search depends on the container data ); } finally { tracking.end(); } } /** * @async * @function getAll * @description Get all objects from the mediumroast.io application * @returns {Array} the results from the called function mrRest class */ async getAll() { // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'getAll') : { end: () =&gt; {} }; try { // Use cache with the container key return await this.cache.getOrFetch( this._cacheKeys.container, () =&gt; this.serverCtl.readObjects(this.objType), this.cacheTimeouts[this.objType] || 60000, [] // No dependencies for the main container ); } catch (error) { return this._createError( `Failed to retrieve ${this.objType}: ${error.message}`, error, 500 ); } finally { tracking.end(); } } /** * @async * @function findByName * @description Find all objects by name from the mediumroast.io application */ async findByName(name) { const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'findByName') : { end: () =&gt; {} }; try { return await this.findByX('name', name); } finally { tracking.end(); } } /** * @async * @function findById * @description Find all objects by id from the mediumroast.io application * @deprecated */ // eslint-disable-next-line no-unused-vars async findById(_id) { logger.warn?.('Method findById is deprecated'); return this._createError('Method findById is deprecated', null, 410); } /** * @async * @function findByX * @description Find all objects by attribute and value pair */ async findByX(attribute, value, allObjects=null) { // Create a cache key for this operation const cacheKey = `${this._cacheKeys.byAttribute}_${attribute}_${value}`; // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'findByX') : { end: () =&gt; {} }; try { // Validate parameters first before using cache const validationError = this._validateParams( { attribute, value }, { attribute: 'string' } ); if (validationError) return validationError; // Use cache with dependencies to the container return await this.cache.getOrFetch( cacheKey, async () =&gt; { // Convert name values to lowercase for case-insensitive matching if(attribute === 'name') { value = typeof value === 'string' ? value.toLowerCase() : value; } let myObjects = []; // If no objects provided, fetch them if(allObjects === null) { const allObjectsResp = await this.getAll(); if (!allObjectsResp[0]) { return allObjectsResp; } allObjects = allObjectsResp[2].mrJson; } // If the length of allObjects is 0 then return an error if(allObjects.length === 0) { return this._createError(`No ${this.objType} found`, null, 404); } // Search for matching objects for(const obj in allObjects) { let currentObject; attribute == 'name' ? currentObject = allObjects[obj][attribute]?.toLowerCase() : currentObject = allObjects[obj][attribute]; if(currentObject === value) { myObjects.push(allObjects[obj]); } } if (myObjects.length === 0) { return this._createError( `No ${this.objType} found where ${attribute} = ${value}`, null, 404 ); } else { return this._createSuccess( `Found ${myObjects.length} objects where ${attribute} = ${value}`, myObjects ); } }, this.cacheTimeouts[this.objType] || 60000, [this._cacheKeys.container] // This operation depends on the container data ); } finally { tracking.end(); } } /** * @async * @function createObj * @description Create objects in the mediumroast.io application */ async createObj(objs) { // Track this operation logger.trackOperation(this.objType, 'createObj'); // Validate parameters const validationError = this._validateParams( { objs }, { objs: 'array' } ); if (validationError) return validationError; // Use transaction pattern for safer operations return this._executeTransaction([ // Step 1: Catch container async () =&gt; { let repoMetadata = { containers: { [this.objType]: {} }, branch: {} }; return await this.serverCtl.catchContainer(repoMetadata); }, // Step 2: Get SHA async (data) =&gt; { return await this.serverCtl.getSha( this.objType, this.objectFiles[this.objType], data.branch.name ); }, // Step 3: Merge and write objects async (sha, data) =&gt; { // Append the new object to the existing objects const mergedObjects = [...data.containers[this.objType].objects, ...objs]; // Write the new objects to the container return await this.serverCtl.writeObject( this.objType, mergedObjects, data.branch.name, sha ); }, // Step 4: Release container async (data) =&gt; { // Release the container const result = await this.serverCtl.releaseContainer(data); // Invalidate cache if successful if (result[0]) { this._invalidateCache(); } return this._createSuccess( `Created [${objs.length}] ${this.objType}`, null ); } ], `create-${this.objType}`); } /** * @async * @function updateObj * @description Update an object in the mediumroast.io application */ async updateObj(objToUpdate, dontWrite=false, system=false) { // Track this operation logger.trackOperation(this.objType, 'updateObj'); // Extract object data const { name, key, value } = objToUpdate; // Validate parameters const validationError = this._validateParams( { name, key }, { name: 'string', key: 'string' } ); if (validationError) return validationError; // Get whitelist for this object type const whitelist = this.whitelists[this.objType] || []; // Use github.js updateObject with proper parameter sequence const result = await this.serverCtl.updateObject( this.objType, name, key, value, dontWrite, system, whitelist ); // Invalidate cache if the update was successful if (result[0] &amp;&amp; !dontWrite) { this._invalidateCache(); } return result; } /** * @async * @function deleteObj * @description Delete an object in the mediumroast.io application */ async deleteObj(objName, source, repoMetadata=null, catchIt=true) { // Track this operation logger.trackOperation(this.objType, 'deleteObj'); // Validate parameters const validationError = this._validateParams( { objName }, { objName: 'string' } ); if (validationError) return validationError; // Delegate to github.js const result = await this.serverCtl.deleteObject( objName, source, repoMetadata, catchIt ); // Invalidate cache if successful if (result[0]) { this._invalidateCache(); } return result; } /** * Perform batch updates on multiple objects * @param {Array} updates - Array of update operations * @returns {Promise&lt;Array&gt;} Results of the update operations */ async batchUpdate(updates) { // Track this operation logger.trackOperation(this.objType, 'batchUpdate'); // Validate parameters const validationError = this._validateParams( { updates }, { updates: 'array' } ); if (validationError) return validationError; // Get whitelist for this object type const whitelist = this.whitelists[this.objType] || []; // Create the repo metadata object for transaction let repoMetadata = { containers: { [this.objType]: {} }, branch: {} }; // Execute a transaction for batch updates return this._executeTransaction([ // Step 1: Catch container async () =&gt; await this.serverCtl.catchContainer(repoMetadata), // Step 2: Get SHA async (data) =&gt; await this.serverCtl.getSha( this.objType, this.objectFiles[this.objType], data.branch.name ), // Step 3: Read objects async () =&gt; { return await this.serverCtl.readObjects(this.objType); }, // Step 4: Apply all updates async (objects) =&gt; { // Make deep copy to prevent unintended side effects const updatedObjects = deepClone(objects.mrJson); for (const update of updates) { const { name, key, value, system = false } = update; // Skip if missing required data if (isEmpty(name) || isEmpty(key)) continue; // Skip unauthorized updates if (!system &amp;&amp; whitelist.indexOf(key) === -1) continue; // Find and update the object let found = false; for (const i in updatedObjects) { if (updatedObjects[i].name === name) { found = true; updatedObjects[i][key] = value; updatedObjects[i].modification_date = new Date().toISOString(); break; } } if (!found) { return this._createError( `Object with name [${name}] not found`, null, 404 ); } } // Store updated objects for next step this._tempObjects = updatedObjects; return this._createSuccess('Applied all updates'); }, // Step 5: Write updated objects async (data) =&gt; await this.serverCtl.writeObject( this.objType, this._tempObjects, data.branch.name, data.containers[this.objType].objectSha ), // Step 6: Release container async (data) =&gt; { const result = await this.serverCtl.releaseContainer(data); // Invalidate cache if successful if (result[0]) { this._invalidateCache(); } return this._createSuccess( `Updated [${updates.length}] objects in [${this.objType}]` ); } ], `batch-update-${this.objType}`); } /** * @async * @function linkObj * @description Link objects in the mediumroast.io application */ linkObj(objs) { // Track this operation logger.trackOperation(this.objType, 'linkObj'); // Validate parameters const validationError = this._validateParams( { objs }, { objs: 'array' } ); if (validationError) return validationError; let linkedObjs = {}; for(const obj in objs) { const objName = objs[obj].name; const sha256Hash = createHash('sha256').update(objName).digest('hex'); linkedObjs[objName] = sha256Hash; } return linkedObjs; } /** * Check if a container is locked * @returns {Promise&lt;Array&gt;} Lock status */ async checkForLock() { // Track this operation logger.trackOperation(this.objType, 'checkForLock'); return await this.serverCtl.checkForLock(this.objType); } /** * Get the latest commit status for a branch * @param {string} branchName - Name of branch to check (default: 'main') * @param {string} repo - Name of the repository (default: 'Megaroast_discovery') * @returns {Promise&lt;Array&gt;} Latest commit information */ async getBranchStatus(branchName = 'main', repo = 'MegaRoast_discovery') { // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'getBranchStatus') : { end: () =&gt; {} }; try { // Create a cache key based on branch and repo const cacheKey = `branch_status_${repo}_${branchName}`; // Use cache with a short timeout since this is used for freshness checks return await this.cache.getOrFetch( cacheKey, async () =&gt; { try { // Initialize Octokit with the token const octokit = new Octokit({ auth: this.token }); // Make GitHub API request using Octokit const response = await octokit.request('GET /repos/{owner}/{repo}/commits', { owner: this.org, repo: repo, sha: branchName, per_page: 1, headers: { 'X-GitHub-Api-Version': '2022-11-28' } }); if (response.data.length === 0) { return this._createError( `No commits found in branch '${branchName}'`, { branchName, repo }, 404 ); } // Format the response to include useful information const latestCommit = response.data[0]; const branchStatus = { sha: latestCommit.sha, commit: { message: latestCommit.commit.message, author: latestCommit.commit.author, committer: latestCommit.commit.committer }, html_url: latestCommit.html_url, timestamp: latestCommit.commit.committer.date, branch: branchName, repository: repo }; return this._createSuccess( `Retrieved latest commit for branch '${branchName}'`, branchStatus ); } catch (error) { // Check for specific Octokit error types if (error.status === 404) { return this._createError( `Repository or branch not found: ${this.org}/${repo}/${branchName}`, error, 404 ); } else if (error.status === 401 || error.status === 403) { return this._createError( `Authentication error accessing ${this.org}/${repo}/${branchName}`, error, error.status ); } // General error handling return this._createError( `Failed to get branch status: ${error.message}`, error, error.status || 500 ); } }, 60000, // Cache for 1 minute [] // No dependencies ); } catch (error) { return this._createError( `Failed to get branch status: ${error.message}`, error, 500 ); } finally { tracking.end(); } } /** * Check if the branch has been updated since a specific commit * @param {string} lastKnownCommitSha - The last known commit SHA * @param {string} branchName - Name of the branch to check (default: 'main') * @param {string} repo - Name of the repository (default: 'MegaRoast_discovery') * @returns {Promise&lt;Array&gt;} Status indicating if an update is needed */ async checkForUpdates(lastKnownCommitSha, branchName = 'main', repo = 'MegaRoast_discovery') { // Track this operation const tracking = logger.trackOperation ? logger.trackOperation(this.objType, 'checkForUpdates') : { end: () =&gt; {} }; try { // Validate parameters if (!lastKnownCommitSha) { return this._createError( 'Missing required parameter: lastKnownCommitSha', null, 400 ); } // Get current branch status const statusResult = await this.getBranchStatus(branchName, repo); if (!statusResult[0]) { return statusResult; // Return error from getBranchStatus } const currentCommitSha = statusResult[2].sha; const updateNeeded = currentCommitSha !== lastKnownCommitSha; // Create response with update status return this._createSuccess( updateNeeded ? `Repository has been updated since commit ${lastKnownCommitSha.substring(0, 7)}` : 'Repository is up to date', { updateNeeded, lastKnownCommitSha, currentCommitSha, repository: repo, branch: branchName, timestamp: new Date().toISOString() } ); } catch (error) { return this._createError( `Failed to check for updates: ${error.message}`, error, 500 ); } finally { tracking.end(); } } } × Search results Close "},"gitHubServer_index.js.html":{"id":"gitHubServer_index.js.html","title":"Source: gitHubServer/index.js","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Source: gitHubServer/index.js /** * Central export point for the GitHubServer API * @author Michael Hay &lt;michael.hay@mediumroast.io&gt; * @file index.js * @copyright 2024 Mediumroast, Inc. All rights reserved. * @license Apache-2.0 * @version 3.0.0 */ // Import all entity classes import { Studies } from './entities/studies.js'; import { Companies } from './entities/companies.js'; import { Interactions } from './entities/interactions.js'; import { Users } from './entities/users.js'; import { Storage } from './entities/storage.js'; import { Actions } from './entities/actions.js'; // Re-export all entities export { Studies, Companies, Interactions, Users, Storage, Actions }; // Export version information export const VERSION = '3.0.0'; // Also export some utility classes if needed by external code export { logger } from './logger.js'; export { CacheManager } from './cache.js'; export { validator } from './schema.js'; × Search results Close "},"gitHubServer_logger.js.html":{"id":"gitHubServer_logger.js.html","title":"Source: gitHubServer/logger.js","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Source: gitHubServer/logger.js /** * Logger module for the GitHubServer API * @file logger.js * @version 3.0.0 */ /* eslint-disable no-console */ // Create a logger with sensible defaults export const logger = { debug: (...args) =&gt; console.debug(`[${new Date().toISOString()}] [DEBUG]`, ...args), info: (...args) =&gt; console.info(`[${new Date().toISOString()}] [INFO]`, ...args), warn: (...args) =&gt; console.warn(`[${new Date().toISOString()}] [WARN]`, ...args), error: (...args) =&gt; console.error(`[${new Date().toISOString()}] [ERROR]`, ...args), // Always return a tracker object with an end method trackOperation: (objType, operation) =&gt; { const startTime = Date.now(); // Only log in debug mode to avoid cluttering the console if (process.env.DEBUG) { console.debug(`[${new Date().toISOString()}] Starting operation: ${objType}.${operation}`); } return { end: () =&gt; { if (process.env.DEBUG) { const duration = Date.now() - startTime; console.debug(`[${new Date().toISOString()}] Completed operation: ${objType}.${operation} (${duration}ms)`); } } }; }, // Similar for transaction tracking trackTransaction: (transactionName) =&gt; { const startTime = Date.now(); if (process.env.DEBUG) { console.debug(`[${new Date().toISOString()}] Starting transaction: ${transactionName}`); } return { end: () =&gt; { if (process.env.DEBUG) { const duration = Date.now() - startTime; console.debug(`[${new Date().toISOString()}] Completed transaction: ${transactionName} (${duration}ms)`); } } }; } }; × Search results Close "},"github_utils.js.html":{"id":"github_utils.js.html","title":"Source: github/utils.js","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Source: github/utils.js /** * @fileoverview Utility functions for GitHub operations * @license Apache-2.0 * @version 3.0.0 */ /** * Encodes content for GitHub API * @param {String|Object} content - Content to encode * @returns {String} Base64 encoded content */ const encodeContent = (content) =&gt; { if (typeof content === 'object') { return Buffer.from(JSON.stringify(content)).toString('base64'); } return Buffer.from(content || '').toString('base64'); }; /** * Decodes content from GitHub API * @param {String} content - Base64 encoded content * @returns {String} Decoded content */ const decodeContent = (content) =&gt; { return Buffer.from(content, 'base64').toString('utf-8'); }; /** * Safely decodes and parses JSON content * @param {String} content - Base64 encoded JSON content * @returns {Object} Parsed JSON object */ const decodeJsonContent = (content) =&gt; { try { return JSON.parse(decodeContent(content)); } catch (err) { return null; } }; /** * Custom URL encoding for special characters * @param {String} str - String to encode * @returns {String} Encoded string */ const customEncodeURIComponent = (str) =&gt; { return str.split('').map(char =&gt; { return encodeURIComponent(char).replace(/[!'()*]/g, (c) =&gt; { return '%' + c.charCodeAt(0).toString(16).toUpperCase(); }); }).join(''); }; export { encodeContent, decodeContent, decodeJsonContent, customEncodeURIComponent }; × Search results Close "},"authorize.js.html":{"id":"authorize.js.html","title":"Source: authorize.js","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Source: authorize.js /** * @fileoverview This file contains the code to authorize the user to the GitHub API * @license Apache-2.0 * @version 3.0.0 * * @author Michael Hay &lt;michael.hay@mediumroast.io&gt; * @file authorize.js * @copyright 2025 Mediumroast, Inc. All rights reserved. * * @class GitHubAuth * @classdesc This class is used to authorize the user to the GitHub API * * @requires open * @requires octoDevAuth * @requires chalk * @requires cli-table3 * * @exports GitHubAuth * * @example * import {GitHubAuth} from './api/authorize.js' * const github = new GitHubAuth(env, environ, configFile) * const githubToken = github.verifyAccessToken() * */ import open from 'open'; import * as octoDevAuth from '@octokit/auth-oauth-device'; import chalk from 'chalk'; import Table from 'cli-table3'; class GitHubAuth { /** * @constructor * @param {Object} env - The environment object * @param {Object} environ - The environmentals object * @param {String} configFile - The configuration file path * @param {Boolean} configExists - Whether the configuration file exists */ constructor(env, environ, configFile, configExists) { this.env = env; this.clientType = 'github-app'; this.configFile = configFile; this.configExists = configExists; this.environ = environ; this.config = configExists ? environ.readConfig(configFile) : null; } /** * Verifies if the GitHub section exists in the configuration * @returns {Boolean} True if the GitHub section exists, otherwise false */ verifyGitHubSection() { if (!this.config) { return false; } return this.config.hasSection('GitHub'); } /** * Gets a value from the configuration file * @private * @param {String} section - The section name in the config file * @param {String} option - The option name in the section * @returns {String|null} The value or null if not found */ getFromConfig(section, option) { if (!this.config) return null; return this.config.hasKey(section, option) ? this.config.get(section, option) : null; } /** * Gets the access token from the configuration file * @returns {String|null} The access token or null if not found */ getAccessTokenFromConfig() { return this.getFromConfig('GitHub', 'token'); } /** * Gets the authentication type from the configuration file * @returns {String|null} The authentication type or null if not found */ getAuthTypeFromConfig() { return this.getFromConfig('GitHub', 'authType'); } /** * Checks if a GitHub token is valid and not expired * @async * @param {String} token - The GitHub token to check * @returns {Array} [isValid, statusObject, userData] */ async checkTokenExpiration(token) { try { const response = await fetch('https://api.github.com/user', { method: 'GET', headers: { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3+json' } }); if (!response.ok) { return [false, {status_code: response.status, status_msg: response.statusText}, null]; } const data = await response.json(); return [true, {status_code: 200, status_msg: response.statusText}, data]; } catch (error) { return [false, {status_code: 500, status_msg: error.message}, null]; } } /** * Gets an access token using the GitHub device flow * @async * @returns {Object} The access token object */ async getAccessTokenDeviceFlow() { // Set the clientId depending on if the config file exists const clientId = this.configExists ? this.env.clientId : this.env.GitHub.clientId; let deviceCode; const deviceauth = octoDevAuth.createOAuthDeviceAuth({ clientType: this.clientType, clientId: clientId, onVerification(verifier) { deviceCode = verifier.device_code; // eslint-disable-next-line no-console console.log( chalk.blue.bold('If supported opening your browser to the Authorization website.\\nIf your browser doesn\\'t open, please copy and paste the Authorization website URL into your browser\\'s address bar.\\n') ); const authWebsitePrefix = 'Authorization website:'; const authCodePrefix = 'Authorization code:'; const authWebsite = chalk.bold.red(verifier.verification_uri); const authCode = chalk.bold.red(verifier.user_code); const table = new Table({ rows: [ [authWebsitePrefix, authWebsite], [authCodePrefix, authCode] ] }); // Use table if available, fallback to plain text const tableString = table.toString(); if (tableString !== '') { // eslint-disable-next-line no-console console.log(tableString); } else { // eslint-disable-next-line no-console console.log(`\\t${authWebsitePrefix} ${authWebsite}`); // eslint-disable-next-line no-console console.log(`\\t${authCodePrefix} ${authCode}`); } // eslint-disable-next-line no-console console.log('\\nCopy and paste the Authorization code into correct field on the Authorization website. Once authorized setup will continue.\\n'); open(verifier.verification_uri); } }); // Call GitHub to obtain the token const accessToken = await deviceauth({type: 'oauth'}); accessToken.deviceCode = deviceCode; return accessToken; } /** * Verifies if the access token is valid and gets a new one if needed * @async * @param {Boolean} saveToConfig - Whether to save to the configuration file, default is true * @returns {Array} [success, statusObject, tokenData] */ async verifyAccessToken(saveToConfig = true) { // Check if config exists and has GitHub section if (this.configExists &amp;&amp; !this.verifyGitHubSection()) { return [ false, {status_code: 500, status_msg: 'The GitHub section is not available in the configuration file'}, null ]; } // Get authorization details let accessToken; let authType = 'deviceFlow'; // Default if (this.configExists) { accessToken = this.getAccessTokenFromConfig(); authType = this.getAuthTypeFromConfig() || authType; } // Check token validity const validToken = this.configExists ? await this.checkTokenExpiration(accessToken) : [false, {status_code: 500, status_msg: 'The configuration file isn\\'t present'}, null]; // If token is valid, return it if (validToken[0] &amp;&amp; this.configExists) { return [ true, {status_code: 200, status_msg: validToken[1].status_msg}, {token: accessToken, authType: authType} ]; } // Token is invalid or missing, handle based on auth type if (authType === 'pat') { // PAT is invalid, caller must handle return [ false, { status_code: 500, status_msg: `The Personal Access Token appears to be invalid and was rejected with an error message [${validToken[1].status_msg}].\\n\\tPlease obtain a new PAT and update the GitHub token setting in the configuration file [${this.configFile}].` }, null ]; } else if (authType === 'deviceFlow') { // Get new token via device flow const tokenData = await this.getAccessTokenDeviceFlow(); // Update config if it exists and saveToConfig is true if (this.configExists &amp;&amp; this.config &amp;&amp; saveToConfig) { let tmpConfig = this.environ.updateConfigSetting(this.config, 'GitHub', 'token', tokenData.token); tmpConfig = this.environ.updateConfigSetting(tmpConfig[1], 'GitHub', 'authType', authType); tmpConfig = this.environ.updateConfigSetting(tmpConfig[1], 'GitHub', 'deviceCode', tokenData.deviceCode); // Save updates this.config = tmpConfig[1]; if (saveToConfig) { await this.config.write(this.configFile); } } return [ true, { status_code: 200, status_msg: `The access token has been successfully updated and saved to the configuration file [${this.configFile}]` }, {token: tokenData.token, authType: authType, deviceCode: tokenData.deviceCode} ]; } // Fallback for unexpected auth type return [ false, {status_code: 500, status_msg: `Unsupported authentication type: ${authType}`}, null ]; } } export {GitHubAuth}; × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Global Methods customEncodeURIComponent(str) Custom URL encoding for special characters Parameters: Name Type Description str String String to encode Source: github/utils.js, line 46 Returns: Encoded string Type String decodeContent(content) Decodes content from GitHub API Parameters: Name Type Description content String Base64 encoded content Source: github/utils.js, line 24 Returns: Decoded content Type String decodeJsonContent(content) Safely decodes and parses JSON content Parameters: Name Type Description content String Base64 encoded JSON content Source: github/utils.js, line 33 Returns: Parsed JSON object Type Object encodeContent(content) Encodes content for GitHub API Parameters: Name Type Description content String | Object Content to encode Source: github/utils.js, line 12 Returns: Base64 encoded content Type String × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Modules Classes BillingManager BranchManager ContainerOperations RepositoryManager ResponseFactory UserManager Methods customEncodeURIComponent(str) Custom URL encoding for special characters Parameters: Name Type Description str String String to encode Source: github/utils.js, line 46 Returns: Encoded string Type String decodeContent(content) Decodes content from GitHub API Parameters: Name Type Description content String Base64 encoded content Source: github/utils.js, line 24 Returns: Decoded content Type String decodeJsonContent(content) Safely decodes and parses JSON content Parameters: Name Type Description content String Base64 encoded JSON content Source: github/utils.js, line 33 Returns: Parsed JSON object Type Object encodeContent(content) Encodes content for GitHub API Parameters: Name Type Description content String | Object Content to encode Source: github/utils.js, line 12 Returns: Base64 encoded content Type String × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Classes Classes BillingManager BranchManager ContainerOperations RepositoryManager ResponseFactory UserManager Methods customEncodeURIComponent(str) Custom URL encoding for special characters Parameters: Name Type Description str String String to encode Source: github/utils.js, line 46 Returns: Encoded string Type String decodeContent(content) Decodes content from GitHub API Parameters: Name Type Description content String Base64 encoded content Source: github/utils.js, line 24 Returns: Decoded content Type String decodeJsonContent(content) Safely decodes and parses JSON content Parameters: Name Type Description content String Base64 encoded JSON content Source: github/utils.js, line 33 Returns: Parsed JSON object Type Object encodeContent(content) Encodes content for GitHub API Parameters: Name Type Description content String | Object Content to encode Source: github/utils.js, line 12 Returns: Base64 encoded content Type String × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Tutorials Classes BillingManager BranchManager ContainerOperations RepositoryManager ResponseFactory UserManager Methods customEncodeURIComponent(str) Custom URL encoding for special characters Parameters: Name Type Description str String String to encode Source: github/utils.js, line 46 Returns: Encoded string Type String decodeContent(content) Decodes content from GitHub API Parameters: Name Type Description content String Base64 encoded content Source: github/utils.js, line 24 Returns: Decoded content Type String decodeJsonContent(content) Safely decodes and parses JSON content Parameters: Name Type Description content String Base64 encoded JSON content Source: github/utils.js, line 33 Returns: Parsed JSON object Type Object encodeContent(content) Encodes content for GitHub API Parameters: Name Type Description content String | Object Content to encode Source: github/utils.js, line 12 Returns: Base64 encoded content Type String × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent mediumroast_api Overview The mediumroast_api is a standalone API/SDK that provides an interface to interact with the Mediumroast. It is designed to simplify the process of integrating with Mediumroast in your applications. Status The present version of the module is in development and is not yet ready for production use. It is being actively developed and tested to ensure that it meets the requirements of the Mediumroast platform. The initial implementation was constructed in node package mediumroast_js and this version is extracted from that package to be used in a standalone manner. At present the module has been tested for Read operations only. The Create, Update and Delete operations are implemented but not yet tested. The module is being tested in a separate project to ensure that Read operations are working as expected. After that the it should be ready for production of Read only use cases. A second step will be to replace the API implementation in mediumroast_js with this module. The final step will be to test the Create, Update and Delete operations in the standalone module and then in mediumroast_js. After that the module will be ready for production use. Installation To install the module, use npm: npm install mediumroast_api. Usage To use the functionalities provided by the mediumroast_api, you can import the module in your JavaScript files: import { Companies, Interactions, Studies, Users } from 'mediumroast_api'; import ConfigParser from 'configparser'; // Read configuration const config = new ConfigParser(); config.read('./config.ini'); const token = config.get('GitHub', 'token'); const org = config.get('GitHub', 'org'); // Create instances const studies = new Studies(token, org, 'my-process'); const companies = new Companies(token, org, 'my-process'); // Get all studies const allStudies = await studies.getAll(); if (allStudies[0]) { console.log(`Found ${allStudies[2].length} studies`); } // Find a specific company const company = await companies.findByName('Acme Corp'); // Check if repository has been updated const branchStatus = await studies.getBranchStatus(); console.log(`Latest commit: ${branchStatus[2].sha}`); // Determine if client needs to update data const lastKnownSha = localStorage.getItem('lastKnownSha'); const updateCheck = await studies.checkForUpdates(lastKnownSha); if (updateCheck[2].updateNeeded) { console.log('Repository has been updated, fetching new data...'); // Update client data here } Key Features Repository Change Detection The module provides a method to check if the repository has been updated since the last known commit. This can be used to determine if the client needs to update its data. const lastKnownSha = localStorage.getItem('lastKnownSha'); const updateCheck = await studies.checkForUpdates(lastKnownSha); if (updateCheck[2].updateNeeded) { console.log('Repository has been updated, fetching new data...'); // Update client data here } Caching System The module provides a caching system that can be used to store data locally. This can be used to reduce the number of API calls made by the client and improve performance. Default cache time is 5 minutes 1 minute cache time for branch status Cache time can be set in the constructor Cache is automatically invalidated when needed // Get all studies const allStudies = await studies.getAll(); if (allStudies[0]) { console.log(`Found ${allStudies[2].length} studies`); } Standardized Response Format The module provides a standardized response format that includes a status code, message, and data. This can be used to easily determine the outcome of an API call and handle errors. [ success, // Boolean indicating success or failure messageOrError, // Success message or error details data // The requested data or null on failure ] API Reference Base Operations getAll(): Get all items findByName(name): Find an item by name findByX(attribute, value): Find objects by arbitrary attribute search(filters, options): Search for items using filters and sorting options getBranchStatus(): Get the latest commit for a branch checkForUpdates(lastKnownSha): Check if the repository has been updated since the last known commit Entities Companies: Manage company-related data and operations generateCompanyProfile(company): Generate a company profile with analytics Interactions: Handle and manage both metadata and content for interactions findByHash(hash): Find an interaction by hash Studies: Manage study-related data and operations Users: Manage user-related data and operations getAuthenticatedUser(): Get the current user information findByLogin(login): Find a user by login findByRole(role): Find users by role Workflows: Manage workflow-related data and operations Authorization: Functions related to authorization processes for the API Documentation The API documentation is available in two formats: API Reference (GitHub Pages): Complete documentation hosted on GitHub Pages API Reference (Markdown): Documentation in Markdown format for in-repository viewing Testing This project uses Vitest as its testing framework, to run the tests for the module, use: npm run test Development Setup To set up the development environment for the module, you can clone the repository and install the dependencies: git clone https://github.com/mediumroast/mediumroast_api.git cd mediumroast_api npm install # install dependencies Run the examples To run the examples provided in the examples directory, you can use the following command: # Run the device flow authentication example 1st to create a token node examples/github-device-auth.js # Run read operations to see if the token is working node examples/github-read-operations.js These examples are provided to demonstrate how to use the module to interact with the Mediumroast API and are focused on read operations and authentication initially. The first example must be run first to prompt you for authentication and create a token which will be stored in examples/config.ini. After that the second example can be run to demonstrate read operations for major entities. Note: The examples assume access to a GitHub organization called MegaRoast which can be used for the purposes of testing of read operations. The examples will be updated as the module is developed to include Create, Update and Delete operations. Contribution Contributions are welcome! Please fork the repository and submit a pull request with your changes. Ensure that your code adheres to the project's coding standards and includes appropriate tests. License This project is licensed under the Apache-2.0 License. See the LICENSE file for more details. Index api/gitHubServer/entities/actions.js actions.js Version: 3.0.0 Author: Michael Hay Copyright: 2024 Mediumroast, Inc. All rights reserved. License: Apache-2.0 Source: gitHubServer/entities/actions.js, line 1 Index api/gitHubServer/entities/storage.js storage.js Version: 3.0.0 Author: Michael Hay Copyright: 2024 Mediumroast, Inc. All rights reserved. License: Apache-2.0 Source: gitHubServer/entities/storage.js, line 2 Index api/gitHubServer/entities/studies.js Studies entity for GitHubServer Version: 3.0.0 Author: Michael Hay Copyright: 2024 Mediumroast, Inc. All rights reserved. License: Apache-2.0 Source: gitHubServer/entities/studies.js, line 1 Index api/gitHubServer/entities/users.js Users entity for GitHubServer Version: 3.0.0 Author: Michael Hay Copyright: 2024 Mediumroast, Inc. All rights reserved. License: Apache-2.0 Source: gitHubServer/entities/users.js, line 1 Index api/gitHubServer/index.js index.js Version: 3.0.0 Author: Michael Hay Copyright: 2024 Mediumroast, Inc. All rights reserved. License: Apache-2.0 Source: gitHubServer/index.js, line 1 Index api/gitHubServer/logger.js logger.js Version: 3.0.0 Source: gitHubServer/logger.js, line 1 Index api/github/billing.js Billing operations for GitHub Version: 3.0.0 License: Apache-2.0 Source: github/billing.js, line 1 Index api/github/branch.js Branch management operations for GitHub Version: 3.0.0 License: Apache-2.0 Source: github/branch.js, line 1 Index api/github/container.js Container operations for GitHub Version: 3.0.0 License: Apache-2.0 Source: github/container.js, line 1 Index api/github/repository.js Repository operations for GitHub Version: 3.0.0 License: Apache-2.0 Source: github/repository.js, line 1 Index api/github/response.js Factory for creating standardized API responses Version: 3.0.0 License: Apache-2.0 Source: github/response.js, line 1 Index api/github/user.js User management operations for GitHub Version: 3.0.0 License: Apache-2.0 Source: github/user.js, line 1 Index api/github/utils.js Utility functions for GitHub operations Version: 3.0.0 License: Apache-2.0 Source: github/utils.js, line 1 × Search results Close "},"Actions_Actions.html":{"id":"Actions_Actions.html","title":"Class: Actions","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Class: Actions Actions new Actions(token, org, processName) Parameters: Name Type Description token string GitHub API token org string GitHub organization name processName string Process name for locking Source: gitHubServer/entities/actions.js, line 21 × Search results Close "},"BillingManager.html":{"id":"BillingManager.html","title":"Class: BillingManager","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Class: BillingManager BillingManager Manages GitHub billing operations new BillingManager(octokit, orgName) Parameters: Name Type Description octokit Object Octokit instance orgName String GitHub organization name Source: github/billing.js, line 12 Methods &lt;async&gt; getActionsBillings() Gets GitHub Actions billing information for the organization Source: github/billing.js, line 27 Returns: ResponseFactory result Type Promise.&lt;Array&gt; &lt;async&gt; getAllBillings() Gets all billing information for the organization Source: github/billing.js, line 96 Returns: ResponseFactory result with combined billing data Type Promise.&lt;Array&gt; &lt;async&gt; getPackagesBillings() Gets GitHub Packages billing information for the organization Source: github/billing.js, line 73 Returns: ResponseFactory result Type Promise.&lt;Array&gt; &lt;async&gt; getStorageBillings() Gets GitHub Packages storage billing information for the organization Source: github/billing.js, line 50 Returns: ResponseFactory result Type Promise.&lt;Array&gt; × Search results Close "},"BranchManager.html":{"id":"BranchManager.html","title":"Class: BranchManager","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Class: BranchManager BranchManager Manages branch operations in GitHub new BranchManager(octokit, orgName, repoName, mainBranchName) Parameters: Name Type Default Description octokit Object Octokit instance orgName String GitHub organization name repoName String GitHub repository name mainBranchName String main Main branch name Source: github/branch.js, line 12 Methods &lt;async&gt; createBranchFromMain() Creates a new branch from the main branch Source: github/branch.js, line 31 Returns: ResponseFactory result Type Promise.&lt;Array&gt; &lt;async&gt; mergeBranchToMain(branchName, sha, commitDescription) Merges a branch into the main branch Parameters: Name Type Default Description branchName String Branch to merge sha String Commit SHA commitDescription String Performed CRUD operation on objects. Commit description Source: github/branch.js, line 69 Returns: ResponseFactory result Type Promise.&lt;Array&gt; × Search results Close "},"CacheManager.html":{"id":"CacheManager.html","title":"Class: CacheManager","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Class: CacheManager CacheManager Smart cache manager for GitHubServer new CacheManager() Source: gitHubServer/cache.js, line 4 Classes CacheManager Methods clear() Clear entire cache Source: gitHubServer/cache.js, line 65 &lt;async&gt; getOrFetch(key, fetchFn, ttl, dependencies) Gets a value from cache or fetches it Parameters: Name Type Description key string Cache key fetchFn function Function to fetch data if not cached ttl number Time to live in milliseconds dependencies Array.&lt;string&gt; Keys this cache depends on Source: gitHubServer/cache.js, line 17 invalidate(key) Invalidate cache entry and its dependents Parameters: Name Type Description key string Cache key to invalidate Source: gitHubServer/cache.js, line 49 × Search results Close "},"ContainerOperations.html":{"id":"ContainerOperations.html","title":"Class: ContainerOperations","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Class: ContainerOperations ContainerOperations Manages container operations (locking, object manipulation) new ContainerOperations(octokit, orgName, repoName, mainBranchName, lockFileName) Parameters: Name Type Description octokit Object Octokit instance orgName String GitHub organization name repoName String GitHub repository name mainBranchName String Main branch name lockFileName String Lock file name Source: github/container.js, line 13 Methods &lt;async&gt; catchContainers(repoMetadata, objectFiles, createBranchFn, readObjectsFn) Catches multiple containers (locks them and prepares for operations) Parameters: Name Type Description repoMetadata Object Container metadata object objectFiles Object Mapping of container names to their object files createBranchFn function Function to create a branch readObjectsFn function Function to read container objects Source: github/container.js, line 166 Returns: ResponseFactory result Type Promise.&lt;Array&gt; &lt;async&gt; checkForLock(containerName) Checks if a container is locked Parameters: Name Type Description containerName String Container name Source: github/container.js, line 35 Returns: ResponseFactory result Type Promise.&lt;Array&gt; &lt;async&gt; lockContainer(containerName) Locks a container Parameters: Name Type Description containerName String Container name Source: github/container.js, line 82 Returns: ResponseFactory result Type Promise.&lt;Array&gt; &lt;async&gt; releaseContainers(repoMetadata, mergeBranchFn) Releases containers (unlocks them and merges changes) Parameters: Name Type Description repoMetadata Object Container metadata object mergeBranchFn function Function to merge branch to main Source: github/container.js, line 238 Returns: ResponseFactory result Type Promise.&lt;Array&gt; &lt;async&gt; unlockContainer(containerName, commitSha, branchName) Unlocks a container Parameters: Name Type Description containerName String Container name commitSha String SHA of the lock file branchName String Branch name Source: github/container.js, line 123 Returns: ResponseFactory result Type Promise.&lt;Array&gt; × Search results Close "},"GitHubFunctions.GitHubFunctions.html":{"id":"GitHubFunctions.GitHubFunctions.html","title":"Class: GitHubFunctions","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Class: GitHubFunctions GitHubFunctions Core functions needed to interact with the GitHub API for mediumroast.io. new GitHubFunctions(token, org, processName) Parameters: Name Type Description token String the GitHub token for the mediumroast.io application org String the GitHub organization for the mediumroast.io application processName String the name of the process that is using the GitHub API Source: github.js, line 43 × Search results Close "},"RepositoryManager.html":{"id":"RepositoryManager.html","title":"Class: RepositoryManager","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Class: RepositoryManager RepositoryManager Manages low-level GitHub repository operations new RepositoryManager(octokit, orgName, repoName) Parameters: Name Type Description octokit Object Octokit instance orgName String GitHub organization name repoName String GitHub repository name Source: github/repository.js, line 13 Methods &lt;async&gt; createOrUpdateFile(path, content, message, branch, sha) Creates or updates a file in the repository Parameters: Name Type Default Description path String Path to the file content String | Object Content to write (will be encoded) message String Commit message branch String Branch name sha String null SHA of the file (if updating) Source: github/repository.js, line 55 Returns: ResponseFactory result Type Promise.&lt;Array&gt; &lt;async&gt; createRepository(description) Creates a repository in the organization Parameters: Name Type Description description String Repository description Source: github/repository.js, line 164 Returns: ResponseFactory result Type Promise.&lt;Array&gt; &lt;async&gt; deleteFile(path, message, branch, sha) Deletes a file from the repository Parameters: Name Type Description path String Path to the file message String Commit message branch String Branch name sha String SHA of the file Source: github/repository.js, line 83 Returns: ResponseFactory result Type Promise.&lt;Array&gt; &lt;async&gt; getActionsBilling() Gets billing information for GitHub Actions Source: github/repository.js, line 133 Returns: ResponseFactory result Type Promise.&lt;Array&gt; &lt;async&gt; getCollaborators() Gets all users (collaborators) for the repository Source: github/repository.js, line 116 Returns: ResponseFactory result Type Promise.&lt;Array&gt; &lt;async&gt; getContent(path, ref) Gets content from the repository Parameters: Name Type Description path String Path to the content ref String Branch or commit reference Source: github/repository.js, line 32 Returns: ResponseFactory result Type Promise.&lt;Array&gt; &lt;async&gt; getOrganization() Gets organization information Source: github/repository.js, line 182 Returns: ResponseFactory result Type Promise.&lt;Array&gt; &lt;async&gt; getStorageBilling() Gets billing information for GitHub Storage Source: github/repository.js, line 148 Returns: ResponseFactory result Type Promise.&lt;Array&gt; &lt;async&gt; getUser() Gets user information Source: github/repository.js, line 103 Returns: ResponseFactory result Type Promise.&lt;Array&gt; × Search results Close "},"ResponseFactory.html":{"id":"ResponseFactory.html","title":"Class: ResponseFactory","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Class: ResponseFactory ResponseFactory Creates standardized API responses for GitHub operations new ResponseFactory() Source: github/response.js, line 10 Methods &lt;static&gt; error(message, error, code) Creates an error response Parameters: Name Type Default Description message String Error message error * null Error object or message code Number 500 HTTP status code Source: github/response.js, line 29 Returns: [false, {status_code, status_msg}, error] Type Array &lt;static&gt; success(message, data, code) Creates a success response Parameters: Name Type Default Description message String Success message data * null Response data code Number 200 HTTP status code Source: github/response.js, line 18 Returns: [true, {status_code, status_msg}, data] Type Array × Search results Close "},"Storage_Storage.html":{"id":"Storage_Storage.html","title":"Class: Storage","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Class: Storage Storage new Storage(token, org, processName) Parameters: Name Type Description token string GitHub API token org string GitHub organization name processName string Process name for locking Source: gitHubServer/entities/storage.js, line 22 × Search results Close "},"Studies_Studies.html":{"id":"Studies_Studies.html","title":"Class: Studies","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Class: Studies Studies new Studies(token, org, processName) Parameters: Name Type Description token string GitHub API token org string GitHub organization name processName string Process name for locking Source: gitHubServer/entities/studies.js, line 20 × Search results Close "},"UserManager.html":{"id":"UserManager.html","title":"Class: UserManager","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Class: UserManager UserManager Manages GitHub user operations new UserManager(octokit, orgName, repoName) Parameters: Name Type Description octokit Object Octokit instance orgName String GitHub organization name repoName String GitHub repository name Source: github/user.js, line 12 Methods &lt;async&gt; addUserToRepository(username, permission) Adds a user to the repository with specified permissions Parameters: Name Type Default Description username String GitHub username to add permission String pull Permission level ('pull', 'push', 'admin', 'maintain', 'triage') Source: github/user.js, line 73 Returns: ResponseFactory result Type Promise.&lt;Array&gt; &lt;async&gt; getAllUsers() Gets all users (collaborators) from the repository Source: github/user.js, line 48 Returns: ResponseFactory result Type Promise.&lt;Array&gt; &lt;async&gt; getCurrentUser() Gets the authenticated user from the GitHub API Source: github/user.js, line 29 Returns: ResponseFactory result Type Promise.&lt;Array&gt; &lt;async&gt; removeUserFromRepository(username) Removes a user from the repository Parameters: Name Type Description username String GitHub username to remove Source: github/user.js, line 98 Returns: ResponseFactory result Type Promise.&lt;Array&gt; × Search results Close "},"Users_Users.html":{"id":"Users_Users.html","title":"Class: Users","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Class: Users Users new Users(token, org, processName) Parameters: Name Type Description token string GitHub API token org string GitHub organization name processName string Process name for locking Source: gitHubServer/entities/users.js, line 20 × Search results Close "},"api_gitHubServer.module_js.html":{"id":"api_gitHubServer.module_js.html","title":"Module: api/gitHubServer.js","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Module: api/gitHubServer.js gitHubServer.js Version: 3.0.0 Author: Michael Hay Copyright: 2024 Mediumroast, Inc. All rights reserved. License: Apache-2.0 Source: gitHubServer.js, line 1 × Search results Close "},"api_gitHubServer_baseObjects.module_js.html":{"id":"api_gitHubServer_baseObjects.module_js.html","title":"Module: api/gitHubServer/baseObjects.js","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Module: api/gitHubServer/baseObjects.js baseObjects.js Version: 3.0.0 Author: Michael Hay Copyright: 2025 Mediumroast, Inc. All rights reserved. License: Apache-2.0 Source: gitHubServer/baseObjects.js, line 1 Classes BaseObjects Methods &lt;async, inner&gt; createObj() Create objects in the mediumroast.io application Source: gitHubServer/baseObjects.js, line 463 &lt;async, inner&gt; deleteObj() Delete an object in the mediumroast.io application Source: gitHubServer/baseObjects.js, line 576 &lt;async, inner&gt; findById() Find all objects by id from the mediumroast.io application Deprecated: Yes Source: gitHubServer/baseObjects.js, line 370 &lt;async, inner&gt; findByName() Find all objects by name from the mediumroast.io application Source: gitHubServer/baseObjects.js, line 354 &lt;async, inner&gt; findByX() Find all objects by attribute and value pair Source: gitHubServer/baseObjects.js, line 382 &lt;async, inner&gt; getAll() Get all objects from the mediumroast.io application Source: gitHubServer/baseObjects.js, line 323 Returns: the results from the called function mrRest class Type Array &lt;async, inner&gt; linkObj() Link objects in the mediumroast.io application Source: gitHubServer/baseObjects.js, line 717 &lt;async, inner&gt; updateObj() Update an object in the mediumroast.io application Source: gitHubServer/baseObjects.js, line 534 × Search results Close "},"api_gitHubServer_baseObjects.module_js.BaseObjects.html":{"id":"api_gitHubServer_baseObjects.module_js.BaseObjects.html","title":"Class: BaseObjects","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Class: BaseObjects api/gitHubServer/baseObjects.js. BaseObjects new BaseObjects(token, org, processName, objType) Parameters: Name Type Description token string GitHub API token org string GitHub organization name processName string Process name for locking objType string Object type Source: gitHubServer/baseObjects.js, line 31 Methods &lt;private&gt; _createError(message, data, statusCode) Creates a standardized error response Parameters: Name Type Default Description message String Error message data Object null Error data statusCode Number 400 HTTP status code Source: gitHubServer/baseObjects.js, line 123 Returns: Standardized error response Type Array &lt;private&gt; _createSuccess(message, data, statusCode) Creates a standardized success response Parameters: Name Type Default Description message String Success message data Object null Response data statusCode Number 200 HTTP status code Source: gitHubServer/baseObjects.js, line 136 Returns: Standardized success response Type Array &lt;async, private&gt; _executeTransaction(operations, transactionName) Executes a series of operations as a transaction Parameters: Name Type Description operations Array.&lt;function()&gt; Array of async functions to execute transactionName String Name of the transaction for logging Source: gitHubServer/baseObjects.js, line 180 Returns: Result of the transaction Type Promise.&lt;Array&gt; &lt;private&gt; _invalidateCache() Invalidate cache entries when data is modified Source: gitHubServer/baseObjects.js, line 103 &lt;private&gt; _validateParams(params, expectedTypes) Validates parameters against expected types Parameters: Name Type Description params Object Parameters to validate expectedTypes Object Expected types for each parameter Source: gitHubServer/baseObjects.js, line 148 Returns: Error response or null if valid Type Array | null &lt;async&gt; batchUpdate(updates) Perform batch updates on multiple objects Parameters: Name Type Description updates Array Array of update operations Source: gitHubServer/baseObjects.js, line 614 Returns: Results of the update operations Type Promise.&lt;Array&gt; &lt;async&gt; checkForLock() Check if a container is locked Source: gitHubServer/baseObjects.js, line 747 Returns: Lock status Type Promise.&lt;Array&gt; &lt;async&gt; checkForUpdates(lastKnownCommitSha, branchName, repo) Check if the branch has been updated since a specific commit Parameters: Name Type Default Description lastKnownCommitSha string The last known commit SHA branchName string main Name of the branch to check (default: 'main') repo string MegaRoast_discovery Name of the repository (default: 'MegaRoast_discovery') Source: gitHubServer/baseObjects.js, line 862 Returns: Status indicating if an update is needed Type Promise.&lt;Array&gt; &lt;async&gt; getBranchStatus(branchName, repo) Get the latest commit status for a branch Parameters: Name Type Default Description branchName string main Name of branch to check (default: 'main') repo string MegaRoast_discovery Name of the repository (default: 'Megaroast_discovery') Source: gitHubServer/baseObjects.js, line 759 Returns: Latest commit information Type Promise.&lt;Array&gt; &lt;async&gt; search(filters, options) Enhanced search functionality with better filtering options Parameters: Name Type Description filters Object Filter criteria options Object Search options (limit, sort, etc) Source: gitHubServer/baseObjects.js, line 244 Returns: Search results Type Promise.&lt;Array&gt; × Search results Close "},"module-GitHubAuth.html":{"id":"module-GitHubAuth.html","title":"Module: GitHubAuth","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Module: GitHubAuth authorize.js Version: 3.0.0 Author: Michael Hay Copyright: 2025 Mediumroast, Inc. All rights reserved. License: Apache-2.0 Source: authorize.js, line 1 Example import {GitHubAuth} from './api/authorize.js' const github = new GitHubAuth(env, environ, configFile) const githubToken = github.verifyAccessToken() Requires module:open module:octoDevAuth module:chalk module:cli-table3 Classes GitHubAuth × Search results Close "},"module-GitHubAuth-GitHubAuth.html":{"id":"module-GitHubAuth-GitHubAuth.html","title":"Class: GitHubAuth","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Class: GitHubAuth GitHubAuth~ GitHubAuth new GitHubAuth(env, environ, configFile, configExists) Parameters: Name Type Description env Object The environment object environ Object The environmentals object configFile String The configuration file path configExists Boolean Whether the configuration file exists Source: authorize.js, line 40 Methods &lt;async&gt; checkTokenExpiration(token) Checks if a GitHub token is valid and not expired Parameters: Name Type Description token String The GitHub token to check Source: authorize.js, line 95 Returns: [isValid, statusObject, userData] Type Array &lt;async&gt; getAccessTokenDeviceFlow() Gets an access token using the GitHub device flow Source: authorize.js, line 121 Returns: The access token object Type Object getAccessTokenFromConfig() Gets the access token from the configuration file Source: authorize.js, line 77 Returns: The access token or null if not found Type String | null getAuthTypeFromConfig() Gets the authentication type from the configuration file Source: authorize.js, line 85 Returns: The authentication type or null if not found Type String | null &lt;private&gt; getFromConfig(section, option) Gets a value from the configuration file Parameters: Name Type Description section String The section name in the config file option String The option name in the section Source: authorize.js, line 67 Returns: The value or null if not found Type String | null &lt;async&gt; verifyAccessToken(saveToConfig) Verifies if the access token is valid and gets a new one if needed Parameters: Name Type Default Description saveToConfig Boolean true Whether to save to the configuration file, default is true Source: authorize.js, line 179 Returns: [success, statusObject, tokenData] Type Array verifyGitHubSection() Verifies if the GitHub section exists in the configuration Source: authorize.js, line 53 Returns: True if the GitHub section exists, otherwise false Type Boolean × Search results Close "},"module-GitHubFunctions.html":{"id":"module-GitHubFunctions.html","title":"Module: GitHubFunctions","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent Module: GitHubFunctions github.js Version: 3.0.0 Author: Michael Hay Copyright: 2025 Mediumroast, Inc. All rights reserved. License: Apache-2.0 Source: github.js, line 1 Example const gitHubCtl = new GitHubFunctions(accessToken, myOrgName, 'mr-cli-setup') const createRepoResp = await gitHubCtl.createRepository() Requires module:octokit Methods &lt;inner&gt; catchContainer(repoMetadata) Catches a container by locking it, creating a new branch, reading the objects Parameters: Name Type Description repoMetadata Object The metadata object Source: github.js, line 972 Returns: Status, message, and metadata Type Promise.&lt;Array&gt; &lt;async, inner&gt; checkForLock(containerName) Checks to see if a container is locked. Parameters: Name Type Description containerName string The name of the container to check for a lock. Source: github.js, line 450 Returns: A promise that resolves to an array containing status and message. Type Promise.&lt;Array&gt; &lt;async, inner&gt; createBranchFromMain() Creates a new branch from the main branch. Source: github.js, line 419 Returns: A promise that resolves to an array containing a boolean indicating success, a message, and the response. Type Promise.&lt;Array&gt; &lt;inner&gt; createContainers() Creates the top level Study, Company and Interaction containers for all mediumroast.io assets Source: github.js, line 402 Returns: An array with position 0 being boolean to signify success/failure and position 1 being the responses or error messages. Type Array &lt;inner&gt; createRepository() Creates a repository, at the organization level, for keeping track of all mediumroast.io assets Source: github.js, line 349 Returns: An array with position 0 being boolean to signify success/failure and position 1 being the created repo or error message. Type Array &lt;async, inner&gt; deleteObject(objName, source, repoMetadata, catchIt) Deletes an object from a specified container Parameters: Name Type Description objName string The name of the object to delete source object The source object that contains the from and to containers repoMetadata object The repository metadata catchIt boolean Whether to catch the container Source: github.js, line 794 Returns: Status, message, and response Type Promise.&lt;Array&gt; &lt;async, inner&gt; getActionsBillings() Gets the complete billing status for actions from the GitHub API Source: github.js, line 329 Returns: An array with position 0 being boolean to signify success/failure and position 1 being the user info or error message. Type Array &lt;async, inner&gt; getAllUsers() Gets all of the users from the GitHub API Source: github.js, line 314 Returns: An array with position 0 being boolean to signify success/failure and position 1 being the user info or error message. Type Array &lt;inner&gt; getGitHubOrg() If the GitHub organization exists retrieves the detail about it and returns to the caller Source: github.js, line 358 Returns: An array with position 0 being boolean to signify success/failure and position 1 being the org or error message. Type Array &lt;async, inner&gt; getRepoSize() Gets the size of the repository in MB Source: github.js, line 387 Returns: An array with position 0 being boolean to signify success/failure and position 1 being the response or error message. Type Array &lt;async, inner&gt; getStorageBillings() Gets the complete billing status for actions from the GitHub API Source: github.js, line 339 Returns: An array with position 0 being boolean to signify success/failure and position 1 being the user info or error message. Type Array &lt;async, inner&gt; getUser() Gets the authenticated user from the GitHub API Source: github.js, line 299 Returns: An array with position 0 being boolean to signify success/failure and position 1 being the user info or error message. Type Array &lt;async, inner&gt; getWorkflowRuns() Gets all of the workflow runs for the repository Source: github.js, line 372 Returns: An array with position 0 being boolean to signify success/failure and position 1 being the response or error message. Type Array &lt;async, inner&gt; lockContainer(containerName) Locks a container by creating a lock file in the container. Parameters: Name Type Description containerName string The name of the container to lock. Source: github.js, line 469 Returns: A promise that resolves to an array containing status and message. Type Promise.&lt;Array&gt; &lt;async, inner&gt; mergeBranchToMain(branchName, mySha [, commitDescription]) Merges a specified branch into the main branch by creating a pull request. Parameters: Name Type Argument Default Description branchName string The name of the branch to merge into main. mySha string The SHA of the commit to use as the head of the pull request. commitDescription string &lt;optional&gt; 'Performed CRUD operation on objects.' The description of the commit. Source: github.js, line 429 Returns: A promise that resolves to an array containing success status, message, and response. Type Promise.&lt;Array&gt; &lt;async, inner&gt; readObjects(containerName) Reads objects from a specified container using the GitHub API. Parameters: Name Type Description containerName string The name of the container to read objects from. Source: github.js, line 614 Returns: Status, message, and contents Type Promise.&lt;Array&gt; &lt;inner&gt; releaseContainer(repoMetadata) Releases a container by unlocking it and merging the branch Parameters: Name Type Description repoMetadata Object The metadata object Source: github.js, line 995 Returns: Status, message, and response Type Promise.&lt;Array&gt; &lt;async, inner&gt; unlockContainer(containerName, commitSha, branchName) Unlocks a container by deleting the lock file in the container. Parameters: Name Type Description containerName string The name of the container to unlock. commitSha string The SHA of the commit to use as the head of the pull request. branchName string The name of the branch to unlock the container on. Source: github.js, line 488 Returns: A promise that resolves to an array containing status and message. Type Promise.&lt;Array&gt; &lt;async, inner&gt; updateObject(containerName, objName, key, value [, dontWrite] [, system] [, whiteList]) Updates an object in a specified container Parameters: Name Type Argument Default Description containerName string The name of the container containing the object objName string The name of the object to update key string The key of the object to update value string The value to update the key with dontWrite boolean &lt;optional&gt; false A flag to indicate if the object should be written back system boolean &lt;optional&gt; false A flag to indicate if the update is a system call whiteList Array &lt;optional&gt; [] A list of keys that are allowed to be updated Source: github.js, line 650 Returns: Status, message, and response Type Promise.&lt;Array&gt; &lt;async, inner&gt; writeObject(containerName, obj, ref, mySha) Writes an object to a specified container using the GitHub API. Parameters: Name Type Description containerName string The name of the container to write the object to. obj object The object to write to the container. ref string The reference to use when writing the object. mySha string The SHA of the current file if updating. Source: github.js, line 580 Returns: Status, message, and response Type Promise.&lt;Array&gt; × Search results Close "},"tutorial-github-auth-tutorial.html":{"id":"tutorial-github-auth-tutorial.html","title":"Tutorial: github-auth-tutorial","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent github-auth-tutorial GitHub Device Authentication Tutorial This tutorial explains how to use the GitHub device flow authentication with the Mediumroast API. Overview GitHub's device flow authentication is ideal for: CLI applications Environments without direct browser access Applications that need to interact with GitHub APIs The Mediumroast API provides built-in support for this authentication method. Prerequisites Before using this authentication method, you'll need: A GitHub account A GitHub OAuth App: Create one at GitHub Developer Settings Note your Client ID (no secret needed for device flow) Set callback URL to http://localhost (required but not used in device flow) Authentication Process The device flow follows these steps: Your application requests a device code from GitHub GitHub returns a user code and verification URL Your application displays these to the user and opens a browser User enters the code on GitHub's website Meanwhile, your application polls GitHub until authentication completes Upon success, GitHub provides an access token Implementation The github-device-auth.js example demonstrates a complete implementation: // Create GitHub Auth instance const github = new GitHubAuth(env, environ, configFile, configExists); // Start device flow authentication const tokenData = await github.getAccessTokenDeviceFlow(); // Save the token for future use const config = environ.readConfig(userConfigFile); let result = environ.updateConfigSetting(config, 'GitHub', 'token', tokenData.token); await result[1].write(userConfigFile); Configuration Management The example shows how to manage configuration: Read from existing config or use defaults Update configuration with new authentication data Save token securely for future sessions Using the Token After authentication, you can use the token with the Mediumroast API: import { Companies, Studies } from 'mediumroast_api'; // Use the saved token const config = new ConfigParser(); config.read('./config.ini'); const token = config.get('GitHub', 'token'); const org = config.get('GitHub', 'org'); // Create API instances const companies = new Companies(token, org, 'my-process'); const studies = new Studies(token, org, 'my-process'); // Make API calls const allCompanies = await companies.getAll(); Security Considerations When implementing authentication: Never commit tokens to source control Consider environment variables for sensitive values Implement token refresh logic for long-running applications Revoke tokens when no longer needed Troubleshooting Common issues: Invalid Client ID: Verify your GitHub OAuth App configuration Authorization Timeout: Users have limited time to complete authorization Rate Limiting: GitHub API has request limits that may affect authentication Scope Issues: Permission errors may indicate insufficient OAuth scopes Complete Example For the full implementation, refer to the github-device-auth.js example in this directory. × Search results Close "},"tutorial-github-read-operations-tutorial.html":{"id":"tutorial-github-read-operations-tutorial.html","title":"Tutorial: github-read-operations-tutorial","body":" Mediumroast for GitHub SDK and CLI Modules api/gitHubServer.jsapi/gitHubServer/baseObjects.jsGitHubAuthGitHubFunctions Classes Actions#ActionsBillingManagerBranchManagerCacheManagerContainerOperationsGitHubFunctions.GitHubFunctionsRepositoryManagerResponseFactoryStorage#StorageStudies#StudiesUserManagerUsers#Usersapi/gitHubServer/baseObjects.js.BaseObjectsGitHubAuth~GitHubAuth Tutorials github-auth-tutorialgithub-read-operations-tutorial Global customEncodeURIComponentdecodeContentdecodeJsonContentencodeContent github-read-operations-tutorial Mediumroast API Read Operations This tutorial demonstrates how to use the read operations in the Mediumroast API to fetch and interact with different types of data stored in GitHub repositories. Overview The Mediumroast API provides access to several entity types stored in GitHub repositories: Studies: Research and analysis documents Companies: Organization profiles Interactions: Communication and engagement records Users: User account information This tutorial shows how to retrieve and work with these entities using the API's read operations. Prerequisites Before using the read operations, you'll need: A GitHub access token with appropriate permissions The name of your GitHub organization A process name (typically the name of your project) Configuration Setup Create a config.ini file with your GitHub credentials: [GitHub] token = your_github_token org = your_organization_name Basic Usage Pattern All entity types follow the same usage pattern: import { Studies, Companies, Interactions, Users } from 'mediumroast_api'; // Initialize with your credentials const studies = new Studies(token, org, 'your-process-name'); const companies = new Companies(token, org, 'your-process-name'); // Fetch all items const [success, message, data] = await studies.getAll(); // Find specific items const study = await studies.findByName('Study Name'); Working with Studies Studies represent research documents or analysis projects: const studies = new Studies(token, org, 'your-process-name'); // Get all studies const allStudies = await studies.getAll(); if (allStudies[0]) { console.log(`Found ${allStudies[2].mrJson.length} studies`); // Access individual studies const firstStudy = allStudies[2].mrJson[0]; console.log(`First study: ${firstStudy.name}`); } // Find a specific study const studyByName = await studies.findByName('Market Analysis 2024'); if (studyByName[0]) { const study = studyByName[2]; console.log(`Found study: ${study.name}`); } Working with Companies Companies represent organization profiles: const companies = new Companies(token, org, 'your-process-name'); // Get all companies const allCompanies = await companies.getAll(); if (allCompanies[0]) { console.log(`Found ${allCompanies[2].mrJson.length} companies`); } // Find a company by name const companyByName = await companies.findByName('Acme Corp'); Working with Interactions Interactions track communications and engagements: const interactions = new Interactions(token, org, 'your-process-name'); // Get all interactions const allInteractions = await interactions.getAll(); // Find an interaction by name const interactionByName = await interactions.findByName('Q1 Customer Meeting'); Working with Users The Users module lets you access user information: const users = new Users(token, org, 'your-process-name'); // Get all users const allUsers = await users.getAll(); // Get current authenticated user const currentUser = await users.getAuthenticatedUser(); console.log(`Logged in as: ${currentUser[2].login}`); Repository Change Detection A powerful feature of the API is the ability to detect changes in the underlying repositories: const studies = new Studies(token, org, 'your-process-name'); // Get current branch status const branchStatus = await studies.getBranchStatus('main', `${org}_discovery`); const currentSha = branchStatus[2].sha; // Check if updates are needed const updateCheck = await studies.checkForUpdates( localStorage.getItem('lastKnownSha'), 'main', `${org}_discovery` ); if (updateCheck[2].updateNeeded) { console.log('Updates available - fetching new data'); // Fetch new data and update local storage localStorage.setItem('lastKnownSha', updateCheck[2].currentCommitSha); } else { console.log('No updates needed - using cached data'); } Client-Side Implementation Here's a practical example of how you might implement data synchronization in a client application: async function synchronizeData(clientSha = null) { // Get cached SHA or use provided one let commitSha = clientSha || localStorage.getItem('lastCommitSha'); // Check if updates are needed const updateCheck = await api.checkForUpdates( commitSha, 'main', `${org}_discovery` ); if (updateCheck[2].updateNeeded) { console.log('Repository has changed, downloading latest data...'); // Fetch the latest data const latestData = await api.getAll(); // Save the new data and SHA localStorage.setItem('lastCommitSha', updateCheck[2].currentCommitSha); localStorage.setItem('cachedData', JSON.stringify(latestData[2])); return latestData[2]; } else { console.log('Using cached data - no updates needed'); return JSON.parse(localStorage.getItem('cachedData')); } } Response Format All API methods return responses in a standardized format: [ success, // Boolean indicating success or failure message, // String message describing the result data // The requested data or null on failure ] This consistent format makes error handling straightforward: const [success, message, data] = await studies.getAll(); if (success) { // Process data console.log(`Found ${data.mrJson.length} studies`); } else { // Handle error console.error(`Error: ${message}`); } Complete Example For a complete working implementation with all entity types, refer to the github-read-operations.js example in this directory. × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
